<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stixdcpy.correction API documentation</title>
<meta name="description" content="This module provides algorithms to correct detector effects
Author: Hualin Xiao (hualin.xiao@fhnw.ch)
Date: Sep. 1, 2021" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stixdcpy.correction</code></h1>
</header>
<section id="section-intro">
<p>This module provides algorithms to correct detector effects
Author: Hualin Xiao (hualin.xiao@fhnw.ch)
Date: Sep. 1, 2021</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python
&#34;&#34;&#34;
    This module provides algorithms to correct detector effects
    Author: Hualin Xiao (hualin.xiao@fhnw.ch)
    Date: Sep. 1, 2021

&#34;&#34;&#34;
import numpy as np
from matplotlib import pyplot as plt

from stixdcpy import instrument as inst
from stixdcpy import science
from stixdcpy import time as sdt
from stixdcpy.logger import logger

DETECTOR_GROUPS = [[1, 2], [6, 7], [5, 11], [12, 13], [14, 15], [10, 16],
                   [8, 9], [3, 4], [31, 32], [26, 27], [22, 28], [20, 21],
                   [18, 19], [17, 23], [24, 25], [29, 30]]
DET_SIBLINGS = {
    0: 1,
    1: 0,
    5: 6,
    6: 5,
    4: 10,
    10: 4,
    11: 12,
    12: 11,
    13: 14,
    14: 13,
    9: 15,
    15: 9,
    7: 8,
    8: 7,
    2: 3,
    3: 2,
    30: 31,
    31: 30,
    25: 26,
    26: 25,
    21: 27,
    27: 21,
    19: 20,
    20: 19,
    17: 18,
    18: 17,
    16: 22,
    22: 16,
    23: 24,
    24: 23,
    28: 29,
    29: 28
}

# detector sibling index


class BackgroundSubtraction(object):
    def __init__(self, l1sig: science.ScienceL1, l1bkg: science.ScienceL1):
        &#34;&#34;&#34;
                   do background subtraction
                Arguments
                l1sig: a L1product instance containing the signal
                l1bkg: a L1Product instance containing the background

                &#34;&#34;&#34;
        self.l1sig = l1sig
        self.l1bkg = l1bkg

        dmask = self.l1bkg.energy_bin_mask - self.l1sig.energy_bin_mask
        if np.any(dmask &lt; 0):
            logger.error(
                &#39;Background subtraction failed due to the background energy range does not cover the signal energy range  &#39;
            )
            return

        #mean_pixel_rate_clip = self.l1bkg.mean_pixel_rate_spectra * self.l1sig.inverse_energy_bin_mask

        self.pixel_bkg_counts = np.array([
            int_time * self.l1bkg.mean_pixel_rate_spectra
            for int_time in self.l1sig.timedel
        ])
        # set counts beyond the signal energy range to 0
        self.subtracted_counts = (self.l1sig.counts - self.pixel_bkg_counts
                                  ) * self.l1sig.inverse_energy_bin_mask

        # Dead time correction needs to be included in the future
        self.subtracted_counts_err = np.sqrt(
            self.l1sig.counts + np.array([int_time * self.l1bkg.mean_pixel_rate_spectra_err ** 2 for int_time in self.l1sig.timedel])) * \
            self.l1sig.inverse_energy_bin_mask
        self.bkg_subtracted_spectrogram = np.sum(self.subtracted_counts,
                                                 axis=(1, 2))

    def peek(self):
        fig, axs = plt.subplots(2, 2)
        self.l1sig.peek(axs[0, 0])
        self.l1bkg.peek(axs[0, 1])
        X, Y = np.meshgrid(self.l1sig.time,
                           np.arange(self.l1sig.min_ebin, self.l1sig.max_ebin))
        im = axs[1, 0].pcolormesh(
            X, Y,
            np.transpose(
                self.bkg_subtracted_spectrogram[:, self.l1sig.min_ebin:self.
                                                l1sig.max_ebin]))
        axs[1, 0].set_yticks(self.l1sig.energies[&#39;channel&#39;]
                             [self.l1sig.min_ebin:self.l1sig.max_ebin:2])
        axs[1, 0].set_yticklabels(
            self.l1sig.energy_bin_names[self.l1sig.min_ebin:self.l1sig.
                                        max_ebin:2])
        fig = plt.gcf()
        cbar = fig.colorbar(im, ax=axs[1, 0])
        cbar.set_label(&#39;Counts&#39;)
        axs[1, 0].set_title(&#39;Bkg sub. counts&#39;)
        axs[1, 0].set_ylabel(&#39;Energy range(keV&#39;)
        axs[1, 0].set_xlabel(f&#34;Seconds since {self.l1sig.T0}s &#34;)
        axs[1, 1].plot(np.sum(self.l1sig.spectrogram, axis=0),
                       drawstyle=&#39;steps-mid&#39;,
                       label=&#39;Before subtraction&#39;)
        axs[1, 1].plot(np.sum(self.bkg_subtracted_spectrogram, axis=0),
                       drawstyle=&#34;steps-mid&#34;,
                       label=&#39;After subtraction&#39;)
        axs[1, 1].plot(np.sum(self.pixel_bkg_counts, axis=(0, 1, 2)),
                       drawstyle=&#34;steps-mid&#34;,
                       label=&#39;background&#39;)
        axs[1, 1].legend()

    def get_background_subtracted_spectrum(self, start_utc=None, end_utc=None):
        &#34;&#34;&#34;
        Get signal background subtracted spectrum

        &#34;&#34;&#34;
        start_unix = sdt.utc2unix(start_utc)
        end_unix = sdt.utc2unix(end_utc)
        start_time = start_unix - self.l1sig.T0_unix
        end_time = end_unix - self.l1sig.T0_unix
        start_i_tbin = np.argmax(
            self.l1sig.time - 0.5 * self.l1sig.timedel &gt;= start_time) if (
                0 &lt;= start_time &lt;= self.l1sig.duration) else 0

        end_i_tbin = np.argmin(
            self.l1sig.time + 0.5 * self.l1sig.timedel &lt;= end_time) if (
                start_time &lt;= end_time &lt;= self.l1sig.duration) else len(
                    self.l1sig.time)
        time_span = self.l1sig.time[end_i_tbin] - self.l1sig.time[
            start_i_tbin] + 0.5 * self.l1sig.timedel[
                start_i_tbin] + 0.5 * self.l1sig.timedel[end_i_tbin]

        bkg_sub_spectra = np.sum(
            self.subtracted_counts[start_i_tbin:end_i_tbin, :, :, :],
            axis=(0, 1, 2)) / time_span,
        bkg_sub_spectra_err = np.sqrt(
            np.sum(self.subtracted_counts_err[start_i_tbin:end_i_tbin, :, :, :]
                   ** 2,
                   axis=(0, 1, 2))) / time_span
        return bkg_sub_spectra, bkg_sub_spectra_err


class LiveTimeCorrection(object):
    pass
    &#34;&#34;&#34;
    #counts is np.array   time_bins, detector, pixel, energy bins
    trigger_rates=l1data[&#39;triggers&#39;][1:,:]/l1data[&#39;timedel&#39;][:-1,None]
    # delta time is off by 1 time bin due a bug in the
    out=np.copy(trigger_rates)
    tau=11e-6
    live_time=1 - tau*trig
    photo_in=trig/(live_time)
        &#34;&#34;&#34;

    @classmethod
    def L1_live_time_correction(cls, triggers, counts_arr, time_bins):
        &#34;&#34;&#34; Live time correction
        Args
            triggers: ndarray
                triggers in the spectrogram
            counts_arr:ndarray
                counts in the spectrogram
            time_bins: ndarray
                time_bins in the spectrogram
        Returns
        live_time_ratio: ndarray
            live time ratio of detectors
        count_rate:
            corrected count rate
        photons_in:
            rate of photons illuminating the detector group

        &#34;&#34;&#34;

        fpga_tau=10.1e-6
        asic_tau=2.63e-6
        trig_tau = fpga_tau+asic_tau

        time_bins = time_bins[:, None]
        photons_in = triggers/(time_bins-trig_tau*triggers)
        #photon rate calculated using triggers 

        correction_factors= np.zeros((time_bins.size, 32))
        time_bins = time_bins[:, :, None, None]

        time_bins = time_bins[:, :, None, None]
        count_rates = counts_arr/time_bins
        # print(counts_arr.shape)
        for det in range(32):
            trig_idx=inst.detector_id_to_trigger_index[det]
            nin=photons_in[:,trig_idx]
            cor_factor=0.94
            live_ratio[:,det]=np.exp(- cor_factor*nin*asic_tau*1e-6)/(1+ nin*trig_tau)

        return correction_factors, corrected_rates , count_rates,photons_in



class TransmissionCorrection(object):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stixdcpy.correction.BackgroundSubtraction"><code class="flex name class">
<span>class <span class="ident">BackgroundSubtraction</span></span>
<span>(</span><span>l1sig: <a title="stixdcpy.science.ScienceL1" href="science.html#stixdcpy.science.ScienceL1">ScienceL1</a>, l1bkg: <a title="stixdcpy.science.ScienceL1" href="science.html#stixdcpy.science.ScienceL1">ScienceL1</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>do background subtraction
Arguments
l1sig: a L1product instance containing the signal
l1bkg: a L1Product instance containing the background</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackgroundSubtraction(object):
    def __init__(self, l1sig: science.ScienceL1, l1bkg: science.ScienceL1):
        &#34;&#34;&#34;
                   do background subtraction
                Arguments
                l1sig: a L1product instance containing the signal
                l1bkg: a L1Product instance containing the background

                &#34;&#34;&#34;
        self.l1sig = l1sig
        self.l1bkg = l1bkg

        dmask = self.l1bkg.energy_bin_mask - self.l1sig.energy_bin_mask
        if np.any(dmask &lt; 0):
            logger.error(
                &#39;Background subtraction failed due to the background energy range does not cover the signal energy range  &#39;
            )
            return

        #mean_pixel_rate_clip = self.l1bkg.mean_pixel_rate_spectra * self.l1sig.inverse_energy_bin_mask

        self.pixel_bkg_counts = np.array([
            int_time * self.l1bkg.mean_pixel_rate_spectra
            for int_time in self.l1sig.timedel
        ])
        # set counts beyond the signal energy range to 0
        self.subtracted_counts = (self.l1sig.counts - self.pixel_bkg_counts
                                  ) * self.l1sig.inverse_energy_bin_mask

        # Dead time correction needs to be included in the future
        self.subtracted_counts_err = np.sqrt(
            self.l1sig.counts + np.array([int_time * self.l1bkg.mean_pixel_rate_spectra_err ** 2 for int_time in self.l1sig.timedel])) * \
            self.l1sig.inverse_energy_bin_mask
        self.bkg_subtracted_spectrogram = np.sum(self.subtracted_counts,
                                                 axis=(1, 2))

    def peek(self):
        fig, axs = plt.subplots(2, 2)
        self.l1sig.peek(axs[0, 0])
        self.l1bkg.peek(axs[0, 1])
        X, Y = np.meshgrid(self.l1sig.time,
                           np.arange(self.l1sig.min_ebin, self.l1sig.max_ebin))
        im = axs[1, 0].pcolormesh(
            X, Y,
            np.transpose(
                self.bkg_subtracted_spectrogram[:, self.l1sig.min_ebin:self.
                                                l1sig.max_ebin]))
        axs[1, 0].set_yticks(self.l1sig.energies[&#39;channel&#39;]
                             [self.l1sig.min_ebin:self.l1sig.max_ebin:2])
        axs[1, 0].set_yticklabels(
            self.l1sig.energy_bin_names[self.l1sig.min_ebin:self.l1sig.
                                        max_ebin:2])
        fig = plt.gcf()
        cbar = fig.colorbar(im, ax=axs[1, 0])
        cbar.set_label(&#39;Counts&#39;)
        axs[1, 0].set_title(&#39;Bkg sub. counts&#39;)
        axs[1, 0].set_ylabel(&#39;Energy range(keV&#39;)
        axs[1, 0].set_xlabel(f&#34;Seconds since {self.l1sig.T0}s &#34;)
        axs[1, 1].plot(np.sum(self.l1sig.spectrogram, axis=0),
                       drawstyle=&#39;steps-mid&#39;,
                       label=&#39;Before subtraction&#39;)
        axs[1, 1].plot(np.sum(self.bkg_subtracted_spectrogram, axis=0),
                       drawstyle=&#34;steps-mid&#34;,
                       label=&#39;After subtraction&#39;)
        axs[1, 1].plot(np.sum(self.pixel_bkg_counts, axis=(0, 1, 2)),
                       drawstyle=&#34;steps-mid&#34;,
                       label=&#39;background&#39;)
        axs[1, 1].legend()

    def get_background_subtracted_spectrum(self, start_utc=None, end_utc=None):
        &#34;&#34;&#34;
        Get signal background subtracted spectrum

        &#34;&#34;&#34;
        start_unix = sdt.utc2unix(start_utc)
        end_unix = sdt.utc2unix(end_utc)
        start_time = start_unix - self.l1sig.T0_unix
        end_time = end_unix - self.l1sig.T0_unix
        start_i_tbin = np.argmax(
            self.l1sig.time - 0.5 * self.l1sig.timedel &gt;= start_time) if (
                0 &lt;= start_time &lt;= self.l1sig.duration) else 0

        end_i_tbin = np.argmin(
            self.l1sig.time + 0.5 * self.l1sig.timedel &lt;= end_time) if (
                start_time &lt;= end_time &lt;= self.l1sig.duration) else len(
                    self.l1sig.time)
        time_span = self.l1sig.time[end_i_tbin] - self.l1sig.time[
            start_i_tbin] + 0.5 * self.l1sig.timedel[
                start_i_tbin] + 0.5 * self.l1sig.timedel[end_i_tbin]

        bkg_sub_spectra = np.sum(
            self.subtracted_counts[start_i_tbin:end_i_tbin, :, :, :],
            axis=(0, 1, 2)) / time_span,
        bkg_sub_spectra_err = np.sqrt(
            np.sum(self.subtracted_counts_err[start_i_tbin:end_i_tbin, :, :, :]
                   ** 2,
                   axis=(0, 1, 2))) / time_span
        return bkg_sub_spectra, bkg_sub_spectra_err</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="stixdcpy.correction.BackgroundSubtraction.get_background_subtracted_spectrum"><code class="name flex">
<span>def <span class="ident">get_background_subtracted_spectrum</span></span>(<span>self, start_utc=None, end_utc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get signal background subtracted spectrum</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background_subtracted_spectrum(self, start_utc=None, end_utc=None):
    &#34;&#34;&#34;
    Get signal background subtracted spectrum

    &#34;&#34;&#34;
    start_unix = sdt.utc2unix(start_utc)
    end_unix = sdt.utc2unix(end_utc)
    start_time = start_unix - self.l1sig.T0_unix
    end_time = end_unix - self.l1sig.T0_unix
    start_i_tbin = np.argmax(
        self.l1sig.time - 0.5 * self.l1sig.timedel &gt;= start_time) if (
            0 &lt;= start_time &lt;= self.l1sig.duration) else 0

    end_i_tbin = np.argmin(
        self.l1sig.time + 0.5 * self.l1sig.timedel &lt;= end_time) if (
            start_time &lt;= end_time &lt;= self.l1sig.duration) else len(
                self.l1sig.time)
    time_span = self.l1sig.time[end_i_tbin] - self.l1sig.time[
        start_i_tbin] + 0.5 * self.l1sig.timedel[
            start_i_tbin] + 0.5 * self.l1sig.timedel[end_i_tbin]

    bkg_sub_spectra = np.sum(
        self.subtracted_counts[start_i_tbin:end_i_tbin, :, :, :],
        axis=(0, 1, 2)) / time_span,
    bkg_sub_spectra_err = np.sqrt(
        np.sum(self.subtracted_counts_err[start_i_tbin:end_i_tbin, :, :, :]
               ** 2,
               axis=(0, 1, 2))) / time_span
    return bkg_sub_spectra, bkg_sub_spectra_err</code></pre>
</details>
</dd>
<dt id="stixdcpy.correction.BackgroundSubtraction.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self):
    fig, axs = plt.subplots(2, 2)
    self.l1sig.peek(axs[0, 0])
    self.l1bkg.peek(axs[0, 1])
    X, Y = np.meshgrid(self.l1sig.time,
                       np.arange(self.l1sig.min_ebin, self.l1sig.max_ebin))
    im = axs[1, 0].pcolormesh(
        X, Y,
        np.transpose(
            self.bkg_subtracted_spectrogram[:, self.l1sig.min_ebin:self.
                                            l1sig.max_ebin]))
    axs[1, 0].set_yticks(self.l1sig.energies[&#39;channel&#39;]
                         [self.l1sig.min_ebin:self.l1sig.max_ebin:2])
    axs[1, 0].set_yticklabels(
        self.l1sig.energy_bin_names[self.l1sig.min_ebin:self.l1sig.
                                    max_ebin:2])
    fig = plt.gcf()
    cbar = fig.colorbar(im, ax=axs[1, 0])
    cbar.set_label(&#39;Counts&#39;)
    axs[1, 0].set_title(&#39;Bkg sub. counts&#39;)
    axs[1, 0].set_ylabel(&#39;Energy range(keV&#39;)
    axs[1, 0].set_xlabel(f&#34;Seconds since {self.l1sig.T0}s &#34;)
    axs[1, 1].plot(np.sum(self.l1sig.spectrogram, axis=0),
                   drawstyle=&#39;steps-mid&#39;,
                   label=&#39;Before subtraction&#39;)
    axs[1, 1].plot(np.sum(self.bkg_subtracted_spectrogram, axis=0),
                   drawstyle=&#34;steps-mid&#34;,
                   label=&#39;After subtraction&#39;)
    axs[1, 1].plot(np.sum(self.pixel_bkg_counts, axis=(0, 1, 2)),
                   drawstyle=&#34;steps-mid&#34;,
                   label=&#39;background&#39;)
    axs[1, 1].legend()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stixdcpy.correction.LiveTimeCorrection"><code class="flex name class">
<span>class <span class="ident">LiveTimeCorrection</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LiveTimeCorrection(object):
    pass
    &#34;&#34;&#34;
    #counts is np.array   time_bins, detector, pixel, energy bins
    trigger_rates=l1data[&#39;triggers&#39;][1:,:]/l1data[&#39;timedel&#39;][:-1,None]
    # delta time is off by 1 time bin due a bug in the
    out=np.copy(trigger_rates)
    tau=11e-6
    live_time=1 - tau*trig
    photo_in=trig/(live_time)
        &#34;&#34;&#34;

    @classmethod
    def L1_live_time_correction(cls, triggers, counts_arr, time_bins):
        &#34;&#34;&#34; Live time correction
        Args
            triggers: ndarray
                triggers in the spectrogram
            counts_arr:ndarray
                counts in the spectrogram
            time_bins: ndarray
                time_bins in the spectrogram
        Returns
        live_time_ratio: ndarray
            live time ratio of detectors
        count_rate:
            corrected count rate
        photons_in:
            rate of photons illuminating the detector group

        &#34;&#34;&#34;

        fpga_tau=10.1e-6
        asic_tau=2.63e-6
        trig_tau = fpga_tau+asic_tau

        time_bins = time_bins[:, None]
        photons_in = triggers/(time_bins-trig_tau*triggers)
        #photon rate calculated using triggers 

        correction_factors= np.zeros((time_bins.size, 32))
        time_bins = time_bins[:, :, None, None]

        time_bins = time_bins[:, :, None, None]
        count_rates = counts_arr/time_bins
        # print(counts_arr.shape)
        for det in range(32):
            trig_idx=inst.detector_id_to_trigger_index[det]
            nin=photons_in[:,trig_idx]
            cor_factor=0.94
            live_ratio[:,det]=np.exp(- cor_factor*nin*asic_tau*1e-6)/(1+ nin*trig_tau)

        return correction_factors, corrected_rates , count_rates,photons_in</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="stixdcpy.correction.LiveTimeCorrection.L1_live_time_correction"><code class="name flex">
<span>def <span class="ident">L1_live_time_correction</span></span>(<span>triggers, counts_arr, time_bins)</span>
</code></dt>
<dd>
<div class="desc"><p>Live time correction
Args
triggers: ndarray
triggers in the spectrogram
counts_arr:ndarray
counts in the spectrogram
time_bins: ndarray
time_bins in the spectrogram
Returns
live_time_ratio: ndarray
live time ratio of detectors
count_rate:
corrected count rate
photons_in:
rate of photons illuminating the detector group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def L1_live_time_correction(cls, triggers, counts_arr, time_bins):
    &#34;&#34;&#34; Live time correction
    Args
        triggers: ndarray
            triggers in the spectrogram
        counts_arr:ndarray
            counts in the spectrogram
        time_bins: ndarray
            time_bins in the spectrogram
    Returns
    live_time_ratio: ndarray
        live time ratio of detectors
    count_rate:
        corrected count rate
    photons_in:
        rate of photons illuminating the detector group

    &#34;&#34;&#34;

    fpga_tau=10.1e-6
    asic_tau=2.63e-6
    trig_tau = fpga_tau+asic_tau

    time_bins = time_bins[:, None]
    photons_in = triggers/(time_bins-trig_tau*triggers)
    #photon rate calculated using triggers 

    correction_factors= np.zeros((time_bins.size, 32))
    time_bins = time_bins[:, :, None, None]

    time_bins = time_bins[:, :, None, None]
    count_rates = counts_arr/time_bins
    # print(counts_arr.shape)
    for det in range(32):
        trig_idx=inst.detector_id_to_trigger_index[det]
        nin=photons_in[:,trig_idx]
        cor_factor=0.94
        live_ratio[:,det]=np.exp(- cor_factor*nin*asic_tau*1e-6)/(1+ nin*trig_tau)

    return correction_factors, corrected_rates , count_rates,photons_in</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stixdcpy.correction.TransmissionCorrection"><code class="flex name class">
<span>class <span class="ident">TransmissionCorrection</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransmissionCorrection(object):
    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stixdcpy" href="index.html">stixdcpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stixdcpy.correction.BackgroundSubtraction" href="#stixdcpy.correction.BackgroundSubtraction">BackgroundSubtraction</a></code></h4>
<ul class="">
<li><code><a title="stixdcpy.correction.BackgroundSubtraction.get_background_subtracted_spectrum" href="#stixdcpy.correction.BackgroundSubtraction.get_background_subtracted_spectrum">get_background_subtracted_spectrum</a></code></li>
<li><code><a title="stixdcpy.correction.BackgroundSubtraction.peek" href="#stixdcpy.correction.BackgroundSubtraction.peek">peek</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stixdcpy.correction.LiveTimeCorrection" href="#stixdcpy.correction.LiveTimeCorrection">LiveTimeCorrection</a></code></h4>
<ul class="">
<li><code><a title="stixdcpy.correction.LiveTimeCorrection.L1_live_time_correction" href="#stixdcpy.correction.LiveTimeCorrection.L1_live_time_correction">L1_live_time_correction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stixdcpy.correction.TransmissionCorrection" href="#stixdcpy.correction.TransmissionCorrection">TransmissionCorrection</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>