<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stixdcpy.science API documentation</title>
<meta name="description" content="This module provides APIs to retrieve Quick-look data from STIX data center , and provides tools to display the data
Author: Hualin Xiao â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stixdcpy.science</code></h1>
</header>
<section id="section-intro">
<p>This module provides APIs to retrieve Quick-look data from STIX data center , and provides tools to display the data
Author: Hualin Xiao (hualin.xiao@fhnw.ch)
Date: Sep. 1, 2021</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python
&#34;&#34;&#34;
    This module provides APIs to retrieve Quick-look data from STIX data center , and provides tools to display the data
    Author: Hualin Xiao (hualin.xiao@fhnw.ch)
    Date: Sep. 1, 2021
&#34;&#34;&#34;
import datetime
import numpy as np
from astropy.io import fits
from matplotlib import pyplot as plt
from stixdcpy import time as sdt
from stixdcpy.logger import logger
from stixdcpy import io as sio, net
from stixdcpy.net import FitsQuery as freq
from stixdcpy import instrument as inst
from pathlib import PurePath

FPGA_TAU=10.1e-6
ASIC_TAU=2.63e-6


class ScienceData(sio.IO):
    &#34;&#34;&#34;
      Retrieve science data from stix data center or load fits file from local storage

    &#34;&#34;&#34;
    def __init__(self, request_id=None, fname=None):
        self.fname = fname
        self.data_type=None
        if not fname:
            raise Exception(&#34;FITS filename not specified&#34;)
        self.request_id = request_id
        self.time_shift_applied=0
        self.hdul = fits.open(fname)
        self.energies=[]
        #self.read_data()
    @property
    def url(self):
        req_id=self.request_id if not isinstance(self.request_id, list) else self.request_id[0]
        link=f&#39;{net.HOST}/view/list/bsd/uid/{req_id}&#39;
        return f&#39;&lt;a href=&#34;{link}&#34;&gt;{link}&lt;/a&gt;&#39;

    def read_fits(self, light_time_correction=True):
        &#34;&#34;&#34;
            Read data  L1 compression level  FITS files
            Parameters
            ---------------------
            light_time_correction: boolean
                Correct light time difference
        &#34;&#34;&#34;

        self.data = self.hdul[&#39;DATA&#39;].data
        self.T0_utc = self.hdul[&#39;PRIMARY&#39;].header[&#39;DATE_BEG&#39;]
        self.counts= self.data[&#39;counts&#39;]

        self.light_time_del= self.hdul[&#39;PRIMARY&#39;].header[&#39;EAR_TDEL&#39;]
        self.light_time_corrected=light_time_correction

        self.T0_unix = sdt.utc2unix(self.T0_utc)
        self.triggers = self.data[&#39;triggers&#39;]
        self.rcr = self.data[&#39;rcr&#39;]

        self.timedel = self.data[&#39;timedel&#39;]
        self.time = self.data[&#39;time&#39;]

        if self.is_time_bin_shifted(self.T0_unix):
            self.timedel = self.timedel[:-1]
            self.time = self.time[1:]
            logger.info(&#39;Shifted time bins have been corrected automatically!&#39;)
            if self.data_type==&#39;ScienceL1&#39;:
                self.counts= self.counts[1:, :, :, :]
                self.triggers = self.triggers[1:, :]
                self.rcr = self.rcr[1:]
            elif self.data_type==&#39;Spectrogram&#39;:
                self.counts= self.counts[1:, :]
                self.triggers = self.triggers[1:]
                #self.rcr = self.rcr[1:]

        self.request_id = self.hdul[&#39;CONTROL&#39;].data[&#39;request_id&#39;]
        
        self.time_shift_applied=0 if light_time_correction else self.light_time_del
        self.datetime = [
            sdt.unix2datetime(self.T0_unix + x + y * 0.5 + self.time_shift_applied)
            for x, y in zip(self.time, self.timedel)
        ]

        self.duration = self.time[-1] - self.time[0] + (self.timedel[0] +
                                                        self.timedel[-1]) / 2

        self.energies = self.hdul[&#39;ENERGIES&#39;].data

        self.energy_bin_names = [
            f&#39;{a} - {b}&#39;
            for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;])
        ]
        self.energy_bin_mask = self.hdul[&#34;CONTROL&#34;].data[&#34;energy_bin_mask&#34;]

        ebin_nz_idx =self.energy_bin_mask.nonzero()
        self.max_ebin = np.max(ebin_nz_idx)  #indices of the non-zero elements
        self.min_ebin = np.min(ebin_nz_idx)

        self.ebins_mid = [
            (a + b) / 2.
            for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;])
        ]
        self.ebins_low, self.ebins_high = self.energies[
            &#39;e_low&#39;], self.energies[&#39;e_high&#39;]

        if self.data_type==&#39;ScienceL1&#39;:
            self.pixel_counts=self.counts
            self.pixel_count_rates= self.pixel_counts/self.timedel[:,None,None, None]
            self.trigger_rates = self.triggers / self.timedel[:, None] 
        elif self.data_type==&#39;Spectrogram&#39;:
            self.count_rates= self.counts/self.timedel[:,None]
            self.trigger_rates = self.triggers / self.timedel


    def is_time_bin_shifted(self, unix_time):
        &#34;&#34;&#34;
            Time bins are shifted in the data collected before 2021-12-09 due a bug in the flight software

            Check if time bin is shifted in L1 data
            Parameters
                unix_time: float 
            Returns
                is_shifted: bool
                    True if time bin is shifted else False
        &#34;&#34;&#34;

        return (unix_time &lt; sdt.utc2unix(&#39;2021-12-09T14:00:00&#39;))

    @classmethod
    def from_sdc(cls, request_id):
        &#39;&#39;&#39;
        download science data file from stix data center
        Parameters
        ------
        request_id :  int
            bulk science data request unique ID; Unique IDs can be found on the science data web page  at stix data center


        Returns
        ------
            science data class object
        &#39;&#39;&#39;
        request_id = request_id
        fname = freq.fetch_bulk_science_by_request_id(request_id)
        return cls(request_id, fname)

    @classmethod
    def from_fits(cls, filename):
        &#34;&#34;&#34;
        factory class
        Arguments
        filename: str
            FITS filename
        &#34;&#34;&#34;
        request_id = None
        return cls(request_id, filename)

    def get_energy_range_slicer(self, elow, ehigh):
        sel=[]
        i=0
        for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;]):
            if a&gt;=elow  and b&lt;=ehigh:
                sel.append(i)
            i+=1
        return slice(min(sel),max(sel))



    def rebin(self, ebins, min_tbin=0):
        &#34;&#34;&#34;
         Energy rebin and time rebin
         Arguments:
         ebins: list or numpy array
            energy bin range in units of keV
         min_tbin: float
            minimum time bin, shorter time bins are merged
         Returns:
            an object containing rebinned light curves
        &#34;&#34;&#34;
        pass

    def save(self, filename=None):
        &#39;&#39;&#39;
           Save data to a fits file
           Parameters
           filename : output fits filename
           Returns
           filename if success or error message
        &#39;&#39;&#39;
        if not isinstance(self.hdul, fits.hdu.hdulist.HDUList):
            logger.error(&#39;The data object is a not a fits hdu object!&#39;)
            return None
        try:
            if filename is None:
                basename = self.hdul[&#39;PRIMARY&#39;].header[&#39;FILENAME&#39;]
                filename = PurePath(net.DOWNLOAD_PATH, basename)
            self.hdul.writeto(filename)
            return filename
        except Exception as e:
            logger.error(e)

    def __getattr__(self, name):
        if name == &#39;data&#39;:
            return self.hdul
        elif name == &#39;type&#39;:
            return self.hdul.get(&#39;data_type&#39;, &#39;INVALID_TYPE&#39;)
        elif name == &#39;filename&#39;:
            return self.fname

    def get_data(self):
        return self.hdul


class ScienceL1(ScienceData):
    &#34;&#34;&#34;
    Tools to analyze L1 science data
    &#34;&#34;&#34;

    def __init__(self, reqeust_id,fname):
        print(reqeust_id, fname)
        super().__init__(reqeust_id, fname)
        self.data_type=&#39;ScienceL1&#39;
        self.pixel_count_rates=None
        self.correct_pixel_count_rates=None
        self.read_fits()
        self.make_spectra()

    def make_spectra(self, pixel_counts=None):
        if pixel_counts is None:
            pixel_counts=self.pixel_counts
        self.spectrogram = np.sum(pixel_counts, axis=(1, 2))
        self.count_rate_spectrogram = self.spectrogram / self.timedel[:, np.
                                                                      newaxis]
        self.spectrum = np.sum(pixel_counts, axis=(0, 1, 2))
        self.mean_pixel_rate_spectra = np.sum(self.pixel_counts,
                                              axis=0) / self.duration
        self.mean_pixel_rate_spectra_err = np.sqrt(
            self.mean_pixel_rate_spectra) / np.sqrt(self.duration)
        #sum over all time bins and then divide them by the duration, counts per second

    def solve_cfl(self, start_utc, end_utc, elow=0, eup=31, ax=None):
        &#34;&#34;&#34;calculate flare location using the online flare location solver.
          
        Args:
            start_utc: str
                ROI start time
            end_utc: str
                ROI end time
            elow: int
                ROI lower energy limit (science channel). 
            eup: int
                ROI upper energy limit (science channel). 
        Returns:
            cfl_loc: dict
                containing coarse flare location as well as ephemeris and chisquare map

        &#34;&#34;&#34;
        pass

    def correct_live_time(self, clone=False):
        &#34;&#34;&#34; Live time correction
        Returns:
          scienceL1 object
        &#34;&#34;&#34;

        trig_tau = FPGA_TAU+ASIC_TAU
        time_bins = self.time_bins[:, None]
        photons_in = self.triggers/(time_bins-trig_tau*self.triggers)
        #photon rate calculated using triggers 
        cm= np.zeros((time_bins.size, 32))
        time_bins = time_bins[:, :, None, None]
        count_rates = self.pixel_counts/time_bins
        for det in range(32):
            trig_idx=inst.detector_id_to_trigger_index(det)

            cm[:,det]= 1 + self.trigger_rates[:,trig_idx]*FPGA_TAU #live time per second 
        self.correct_pixel_count_rates=count_rates*cm[:, :, None, None]/np.exp(-count_rates*ASIC_TAU)
        return self

    def peek(self,
             plots=[&#39;spg&#39;, &#39;lc&#39;, &#39;spec&#39;, &#39;tbin&#39;, &#39;qllc&#39;],
             ax0=None,
             ax1=None,
             ax2=None,
             ax3=None):
        &#34;&#34;&#34;
            Create quick-look plots for the loaded science data
        &#34;&#34;&#34;
        if not self.hdul:
            logger.logger(f&#39;Data not loaded. &#39;)
            return None
        if isinstance(plots, str) and plots:
            plots = plots.split(&#39;,&#39;)
        if not self.data_loaded:
            self.read_fits()
            self.data_loaded = True

        if &#39;spg&#39; in plots:
            if not ax0:
                _, ax0 = plt.subplots()
            X, Y = np.meshgrid(self.time,
                               np.arange(self.min_ebin, self.max_ebin))
            im = ax0.pcolormesh(
                X, Y,
                np.transpose(
                    self.count_rate_spectrogram[:, self.min_ebin:self.max_ebin]
                ))  #pixel summed energy spectrum
            ax0.set_yticks(
                self.energies[&#39;channel&#39;][self.min_ebin:self.max_ebin:2])
            ax0.set_yticklabels(
                self.energy_bin_names[self.min_ebin:self.max_ebin:2])
            fig = plt.gcf()
            cbar = fig.colorbar(im, ax=ax0)
            cbar.set_label(&#39;Counts&#39;)
            ax0.set_title(&#39;Count rate spectrogram&#39;)
            ax0.set_ylabel(&#39;Energy range(keV&#39;)
            ax0.set_xlabel(f&#34;T0 at {self.T0_utc} &#34;)
        if &#39;lc&#39; in plots or &#39;qllc&#39; in plots:
            if not ax1:
                _, ax1 = plt.subplots()
            self.count_rate_spectrogram = self.spectrogram / self.timedel[:,
                                                                          None]
            if &#39;qllc&#39; in plots:
               ql_ebins=[(4, 10),(10 ,15 ),(15 ,25 ),(25 ,50), (50 ,84)]
               labels=(&#39;4 - 10 keV&#39;,&#39;10 - 15 keV&#39;,&#39;15 - 25 keV&#39;,&#39;25 - 50 keV&#39;, &#39;50 - 84 keV&#39;)
               ql_sci_ebins=[self.get_energy_range_slicer(s[0],s[1]) for s in ql_ebins]
               for ebin_slicer,label in zip(ql_sci_ebins, labels):
                   ax1.plot(self.time,
                        np.sum(self.count_rate_spectrogram[:, ebin_slicer], axis=1),label=label) 
                   ax1.set_title(f&#39;Detector summed count rates (L1 request #{self.request_id})&#39;)
            else:
                ax1.plot(
                    self.time,
                    self.count_rate_spectrogram[:, self.min_ebin:self.max_ebin])
            #correct
            ax1.set_ylabel(&#39;counts / sec&#39;)
            #plt.legend(self.energy_bin_names, ncol=4)
            ax1.set_yscale(&#39;log&#39;)
            ax1.set_xlabel(f&#34;seconds since {self.T0_utc} &#34;)
            plt.legend()
        if &#39;spec&#39; in plots:
            if not ax2:
                _, ax2 = plt.subplots()
            ax2.plot(self.ebins_low, self.spectrum, drawstyle=&#39;steps-post&#39;)
            #ax.set_xticks(self.data[3].data[&#39;channel&#39;])
            ax2.set_xscale(&#39;log&#39;)
            ax2.set_yscale(&#39;log&#39;)
            ax2.set_xlabel(&#39;Energy (keV)&#39;)
            ax2.set_ylabel(&#39;Counts&#39;)
        if &#39;tbin&#39; in plots:
            if not ax3:
                _, ax3 = plt.subplots()
            ax3.plot(self.time, self.timedel)
            ax3.set_xlabel(f&#34;T0 at {self.T0_utc} &#34;)
            ax3.set_ylabel(&#39;Integration time (sec)&#39;)
            plt.suptitle(f&#39;L1 request #{self.request_id}&#39;)

        #plt.tight_layout()
        return ax0, ax1, ax2, ax3


class Spectrogram(ScienceData):


    def __init__(self, reqeust_id,fname):
        super().__init__(reqeust_id, fname)
        self.data_type=&#39;Spectrogram&#39;

        self.read_fits()

        self.spectrum = np.sum(self.counts, axis=0)

    def peek(self, ax0=None, ax1=None, ax2=None, ax3=None):
        &#34;&#34;&#34;
            preivew Science data
        Arguments:
        ax0: matplotlib axe 
        ax0: matplotlib axe 
        &#34;&#34;&#34;
        if not self.hdul:
            print(f&#39;Data not loaded. &#39;)
            return None

        #((ax0, ax1), (ax2, ax3))=axs
        if not any([ax0, ax1, ax2, ax3]):
            _, ((ax0, ax1), (ax2, ax3)) = plt.subplots(2, 2, figsize=(8, 6))

        if ax0:
            X, Y = np.meshgrid(self.time,
                               self.hdul[&#39;ENERGIES&#39;].data[&#39;channel&#39;])
            im = ax0.pcolormesh(X, Y, np.transpose(
                self.counts))  #pixel summed energy spectrum
            ax0.set_yticks(self.hdul[&#39;ENERGIES&#39;].data[&#39;channel&#39;][::2])
            ax0.set_yticklabels(self.energy_bin_names[::2])
            fig = plt.gcf()
            cbar = fig.colorbar(im, ax=ax0)
            cbar.set_label(&#39;Counts&#39;)
            ax0.set_title(&#39;Spectrogram&#39;)
            ax0.set_ylabel(&#39;Energy range(keV&#39;)
            ax0.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
        if ax1:
            #convert to 2d
            ax1.plot(self.time, self.count_rates)
            ax1.set_yscale(&#39;log&#39;)
            ax1.set_ylabel(&#39;Counts / sec&#39;)
            ax1.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
        if ax2:
            ax2.plot(self.ebins_low, self.spectrum, drawstyle=&#39;steps-post&#39;)
            ax2.set_xscale(&#39;log&#39;)
            ax2.set_yscale(&#39;log&#39;)
            ax2.set_xlabel(&#39;Energy (keV)&#39;)
            ax2.set_ylabel(&#39;Counts&#39;)
        if ax3:
            ax3.plot(self.time, self.timedel)
            ax3.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
            ax3.set_ylabel(&#39;Integration time (sec)&#39;)
        plt.suptitle(f&#39;L4 request #{self.request_id}&#39;)
        plt.tight_layout()
        return fig, ((ax0, ax1), (ax2, ax3))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stixdcpy.science.ScienceData"><code class="flex name class">
<span>class <span class="ident">ScienceData</span></span>
<span>(</span><span>request_id=None, fname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve science data from stix data center or load fits file from local storage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScienceData(sio.IO):
    &#34;&#34;&#34;
      Retrieve science data from stix data center or load fits file from local storage

    &#34;&#34;&#34;
    def __init__(self, request_id=None, fname=None):
        self.fname = fname
        self.data_type=None
        if not fname:
            raise Exception(&#34;FITS filename not specified&#34;)
        self.request_id = request_id
        self.time_shift_applied=0
        self.hdul = fits.open(fname)
        self.energies=[]
        #self.read_data()
    @property
    def url(self):
        req_id=self.request_id if not isinstance(self.request_id, list) else self.request_id[0]
        link=f&#39;{net.HOST}/view/list/bsd/uid/{req_id}&#39;
        return f&#39;&lt;a href=&#34;{link}&#34;&gt;{link}&lt;/a&gt;&#39;

    def read_fits(self, light_time_correction=True):
        &#34;&#34;&#34;
            Read data  L1 compression level  FITS files
            Parameters
            ---------------------
            light_time_correction: boolean
                Correct light time difference
        &#34;&#34;&#34;

        self.data = self.hdul[&#39;DATA&#39;].data
        self.T0_utc = self.hdul[&#39;PRIMARY&#39;].header[&#39;DATE_BEG&#39;]
        self.counts= self.data[&#39;counts&#39;]

        self.light_time_del= self.hdul[&#39;PRIMARY&#39;].header[&#39;EAR_TDEL&#39;]
        self.light_time_corrected=light_time_correction

        self.T0_unix = sdt.utc2unix(self.T0_utc)
        self.triggers = self.data[&#39;triggers&#39;]
        self.rcr = self.data[&#39;rcr&#39;]

        self.timedel = self.data[&#39;timedel&#39;]
        self.time = self.data[&#39;time&#39;]

        if self.is_time_bin_shifted(self.T0_unix):
            self.timedel = self.timedel[:-1]
            self.time = self.time[1:]
            logger.info(&#39;Shifted time bins have been corrected automatically!&#39;)
            if self.data_type==&#39;ScienceL1&#39;:
                self.counts= self.counts[1:, :, :, :]
                self.triggers = self.triggers[1:, :]
                self.rcr = self.rcr[1:]
            elif self.data_type==&#39;Spectrogram&#39;:
                self.counts= self.counts[1:, :]
                self.triggers = self.triggers[1:]
                #self.rcr = self.rcr[1:]

        self.request_id = self.hdul[&#39;CONTROL&#39;].data[&#39;request_id&#39;]
        
        self.time_shift_applied=0 if light_time_correction else self.light_time_del
        self.datetime = [
            sdt.unix2datetime(self.T0_unix + x + y * 0.5 + self.time_shift_applied)
            for x, y in zip(self.time, self.timedel)
        ]

        self.duration = self.time[-1] - self.time[0] + (self.timedel[0] +
                                                        self.timedel[-1]) / 2

        self.energies = self.hdul[&#39;ENERGIES&#39;].data

        self.energy_bin_names = [
            f&#39;{a} - {b}&#39;
            for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;])
        ]
        self.energy_bin_mask = self.hdul[&#34;CONTROL&#34;].data[&#34;energy_bin_mask&#34;]

        ebin_nz_idx =self.energy_bin_mask.nonzero()
        self.max_ebin = np.max(ebin_nz_idx)  #indices of the non-zero elements
        self.min_ebin = np.min(ebin_nz_idx)

        self.ebins_mid = [
            (a + b) / 2.
            for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;])
        ]
        self.ebins_low, self.ebins_high = self.energies[
            &#39;e_low&#39;], self.energies[&#39;e_high&#39;]

        if self.data_type==&#39;ScienceL1&#39;:
            self.pixel_counts=self.counts
            self.pixel_count_rates= self.pixel_counts/self.timedel[:,None,None, None]
            self.trigger_rates = self.triggers / self.timedel[:, None] 
        elif self.data_type==&#39;Spectrogram&#39;:
            self.count_rates= self.counts/self.timedel[:,None]
            self.trigger_rates = self.triggers / self.timedel


    def is_time_bin_shifted(self, unix_time):
        &#34;&#34;&#34;
            Time bins are shifted in the data collected before 2021-12-09 due a bug in the flight software

            Check if time bin is shifted in L1 data
            Parameters
                unix_time: float 
            Returns
                is_shifted: bool
                    True if time bin is shifted else False
        &#34;&#34;&#34;

        return (unix_time &lt; sdt.utc2unix(&#39;2021-12-09T14:00:00&#39;))

    @classmethod
    def from_sdc(cls, request_id):
        &#39;&#39;&#39;
        download science data file from stix data center
        Parameters
        ------
        request_id :  int
            bulk science data request unique ID; Unique IDs can be found on the science data web page  at stix data center


        Returns
        ------
            science data class object
        &#39;&#39;&#39;
        request_id = request_id
        fname = freq.fetch_bulk_science_by_request_id(request_id)
        return cls(request_id, fname)

    @classmethod
    def from_fits(cls, filename):
        &#34;&#34;&#34;
        factory class
        Arguments
        filename: str
            FITS filename
        &#34;&#34;&#34;
        request_id = None
        return cls(request_id, filename)

    def get_energy_range_slicer(self, elow, ehigh):
        sel=[]
        i=0
        for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;]):
            if a&gt;=elow  and b&lt;=ehigh:
                sel.append(i)
            i+=1
        return slice(min(sel),max(sel))



    def rebin(self, ebins, min_tbin=0):
        &#34;&#34;&#34;
         Energy rebin and time rebin
         Arguments:
         ebins: list or numpy array
            energy bin range in units of keV
         min_tbin: float
            minimum time bin, shorter time bins are merged
         Returns:
            an object containing rebinned light curves
        &#34;&#34;&#34;
        pass

    def save(self, filename=None):
        &#39;&#39;&#39;
           Save data to a fits file
           Parameters
           filename : output fits filename
           Returns
           filename if success or error message
        &#39;&#39;&#39;
        if not isinstance(self.hdul, fits.hdu.hdulist.HDUList):
            logger.error(&#39;The data object is a not a fits hdu object!&#39;)
            return None
        try:
            if filename is None:
                basename = self.hdul[&#39;PRIMARY&#39;].header[&#39;FILENAME&#39;]
                filename = PurePath(net.DOWNLOAD_PATH, basename)
            self.hdul.writeto(filename)
            return filename
        except Exception as e:
            logger.error(e)

    def __getattr__(self, name):
        if name == &#39;data&#39;:
            return self.hdul
        elif name == &#39;type&#39;:
            return self.hdul.get(&#39;data_type&#39;, &#39;INVALID_TYPE&#39;)
        elif name == &#39;filename&#39;:
            return self.fname

    def get_data(self):
        return self.hdul</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stixdcpy.io.IO" href="io.html#stixdcpy.io.IO">IO</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stixdcpy.science.ScienceL1" href="#stixdcpy.science.ScienceL1">ScienceL1</a></li>
<li><a title="stixdcpy.science.Spectrogram" href="#stixdcpy.science.Spectrogram">Spectrogram</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="stixdcpy.science.ScienceData.from_fits"><code class="name flex">
<span>def <span class="ident">from_fits</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>factory class
Arguments
filename: str
FITS filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_fits(cls, filename):
    &#34;&#34;&#34;
    factory class
    Arguments
    filename: str
        FITS filename
    &#34;&#34;&#34;
    request_id = None
    return cls(request_id, filename)</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceData.from_sdc"><code class="name flex">
<span>def <span class="ident">from_sdc</span></span>(<span>request_id)</span>
</code></dt>
<dd>
<div class="desc"><p>download science data file from stix data center
Parameters</p>
<hr>
<dl>
<dt><strong><code>request_id</code></strong> :&ensp;<code> int</code></dt>
<dd>bulk science data request unique ID; Unique IDs can be found on the science data web page
at stix data center</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>science data class object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_sdc(cls, request_id):
    &#39;&#39;&#39;
    download science data file from stix data center
    Parameters
    ------
    request_id :  int
        bulk science data request unique ID; Unique IDs can be found on the science data web page  at stix data center


    Returns
    ------
        science data class object
    &#39;&#39;&#39;
    request_id = request_id
    fname = freq.fetch_bulk_science_by_request_id(request_id)
    return cls(request_id, fname)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="stixdcpy.science.ScienceData.url"><code class="name">var <span class="ident">url</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self):
    req_id=self.request_id if not isinstance(self.request_id, list) else self.request_id[0]
    link=f&#39;{net.HOST}/view/list/bsd/uid/{req_id}&#39;
    return f&#39;&lt;a href=&#34;{link}&#34;&gt;{link}&lt;/a&gt;&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="stixdcpy.science.ScienceData.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self):
    return self.hdul</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceData.get_energy_range_slicer"><code class="name flex">
<span>def <span class="ident">get_energy_range_slicer</span></span>(<span>self, elow, ehigh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_energy_range_slicer(self, elow, ehigh):
    sel=[]
    i=0
    for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;]):
        if a&gt;=elow  and b&lt;=ehigh:
            sel.append(i)
        i+=1
    return slice(min(sel),max(sel))</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceData.is_time_bin_shifted"><code class="name flex">
<span>def <span class="ident">is_time_bin_shifted</span></span>(<span>self, unix_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Time bins are shifted in the data collected before 2021-12-09 due a bug in the flight software</p>
<p>Check if time bin is shifted in L1 data
Parameters
unix_time: float
Returns
is_shifted: bool
True if time bin is shifted else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_time_bin_shifted(self, unix_time):
    &#34;&#34;&#34;
        Time bins are shifted in the data collected before 2021-12-09 due a bug in the flight software

        Check if time bin is shifted in L1 data
        Parameters
            unix_time: float 
        Returns
            is_shifted: bool
                True if time bin is shifted else False
    &#34;&#34;&#34;

    return (unix_time &lt; sdt.utc2unix(&#39;2021-12-09T14:00:00&#39;))</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceData.read_fits"><code class="name flex">
<span>def <span class="ident">read_fits</span></span>(<span>self, light_time_correction=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Read data
L1 compression level
FITS files
Parameters</p>
<hr>
<dl>
<dt><strong><code>light_time_correction</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Correct light time difference</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_fits(self, light_time_correction=True):
    &#34;&#34;&#34;
        Read data  L1 compression level  FITS files
        Parameters
        ---------------------
        light_time_correction: boolean
            Correct light time difference
    &#34;&#34;&#34;

    self.data = self.hdul[&#39;DATA&#39;].data
    self.T0_utc = self.hdul[&#39;PRIMARY&#39;].header[&#39;DATE_BEG&#39;]
    self.counts= self.data[&#39;counts&#39;]

    self.light_time_del= self.hdul[&#39;PRIMARY&#39;].header[&#39;EAR_TDEL&#39;]
    self.light_time_corrected=light_time_correction

    self.T0_unix = sdt.utc2unix(self.T0_utc)
    self.triggers = self.data[&#39;triggers&#39;]
    self.rcr = self.data[&#39;rcr&#39;]

    self.timedel = self.data[&#39;timedel&#39;]
    self.time = self.data[&#39;time&#39;]

    if self.is_time_bin_shifted(self.T0_unix):
        self.timedel = self.timedel[:-1]
        self.time = self.time[1:]
        logger.info(&#39;Shifted time bins have been corrected automatically!&#39;)
        if self.data_type==&#39;ScienceL1&#39;:
            self.counts= self.counts[1:, :, :, :]
            self.triggers = self.triggers[1:, :]
            self.rcr = self.rcr[1:]
        elif self.data_type==&#39;Spectrogram&#39;:
            self.counts= self.counts[1:, :]
            self.triggers = self.triggers[1:]
            #self.rcr = self.rcr[1:]

    self.request_id = self.hdul[&#39;CONTROL&#39;].data[&#39;request_id&#39;]
    
    self.time_shift_applied=0 if light_time_correction else self.light_time_del
    self.datetime = [
        sdt.unix2datetime(self.T0_unix + x + y * 0.5 + self.time_shift_applied)
        for x, y in zip(self.time, self.timedel)
    ]

    self.duration = self.time[-1] - self.time[0] + (self.timedel[0] +
                                                    self.timedel[-1]) / 2

    self.energies = self.hdul[&#39;ENERGIES&#39;].data

    self.energy_bin_names = [
        f&#39;{a} - {b}&#39;
        for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;])
    ]
    self.energy_bin_mask = self.hdul[&#34;CONTROL&#34;].data[&#34;energy_bin_mask&#34;]

    ebin_nz_idx =self.energy_bin_mask.nonzero()
    self.max_ebin = np.max(ebin_nz_idx)  #indices of the non-zero elements
    self.min_ebin = np.min(ebin_nz_idx)

    self.ebins_mid = [
        (a + b) / 2.
        for a, b in zip(self.energies[&#39;e_low&#39;], self.energies[&#39;e_high&#39;])
    ]
    self.ebins_low, self.ebins_high = self.energies[
        &#39;e_low&#39;], self.energies[&#39;e_high&#39;]

    if self.data_type==&#39;ScienceL1&#39;:
        self.pixel_counts=self.counts
        self.pixel_count_rates= self.pixel_counts/self.timedel[:,None,None, None]
        self.trigger_rates = self.triggers / self.timedel[:, None] 
    elif self.data_type==&#39;Spectrogram&#39;:
        self.count_rates= self.counts/self.timedel[:,None]
        self.trigger_rates = self.triggers / self.timedel</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceData.rebin"><code class="name flex">
<span>def <span class="ident">rebin</span></span>(<span>self, ebins, min_tbin=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Energy rebin and time rebin
Arguments:
ebins: list or numpy array
energy bin range in units of keV
min_tbin: float
minimum time bin, shorter time bins are merged</p>
<h2 id="returns">Returns</h2>
<p>an object containing rebinned light curves</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebin(self, ebins, min_tbin=0):
    &#34;&#34;&#34;
     Energy rebin and time rebin
     Arguments:
     ebins: list or numpy array
        energy bin range in units of keV
     min_tbin: float
        minimum time bin, shorter time bins are merged
     Returns:
        an object containing rebinned light curves
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceData.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save data to a fits file
Parameters
filename : output fits filename
Returns
filename if success or error message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename=None):
    &#39;&#39;&#39;
       Save data to a fits file
       Parameters
       filename : output fits filename
       Returns
       filename if success or error message
    &#39;&#39;&#39;
    if not isinstance(self.hdul, fits.hdu.hdulist.HDUList):
        logger.error(&#39;The data object is a not a fits hdu object!&#39;)
        return None
    try:
        if filename is None:
            basename = self.hdul[&#39;PRIMARY&#39;].header[&#39;FILENAME&#39;]
            filename = PurePath(net.DOWNLOAD_PATH, basename)
        self.hdul.writeto(filename)
        return filename
    except Exception as e:
        logger.error(e)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="stixdcpy.io.IO" href="io.html#stixdcpy.io.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="stixdcpy.io.IO.dump" href="io.html#stixdcpy.io.IO.dump">dump</a></code></li>
<li><code><a title="stixdcpy.io.IO.load" href="io.html#stixdcpy.io.IO.load">load</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="stixdcpy.science.ScienceL1"><code class="flex name class">
<span>class <span class="ident">ScienceL1</span></span>
<span>(</span><span>reqeust_id, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Tools to analyze L1 science data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScienceL1(ScienceData):
    &#34;&#34;&#34;
    Tools to analyze L1 science data
    &#34;&#34;&#34;

    def __init__(self, reqeust_id,fname):
        print(reqeust_id, fname)
        super().__init__(reqeust_id, fname)
        self.data_type=&#39;ScienceL1&#39;
        self.pixel_count_rates=None
        self.correct_pixel_count_rates=None
        self.read_fits()
        self.make_spectra()

    def make_spectra(self, pixel_counts=None):
        if pixel_counts is None:
            pixel_counts=self.pixel_counts
        self.spectrogram = np.sum(pixel_counts, axis=(1, 2))
        self.count_rate_spectrogram = self.spectrogram / self.timedel[:, np.
                                                                      newaxis]
        self.spectrum = np.sum(pixel_counts, axis=(0, 1, 2))
        self.mean_pixel_rate_spectra = np.sum(self.pixel_counts,
                                              axis=0) / self.duration
        self.mean_pixel_rate_spectra_err = np.sqrt(
            self.mean_pixel_rate_spectra) / np.sqrt(self.duration)
        #sum over all time bins and then divide them by the duration, counts per second

    def solve_cfl(self, start_utc, end_utc, elow=0, eup=31, ax=None):
        &#34;&#34;&#34;calculate flare location using the online flare location solver.
          
        Args:
            start_utc: str
                ROI start time
            end_utc: str
                ROI end time
            elow: int
                ROI lower energy limit (science channel). 
            eup: int
                ROI upper energy limit (science channel). 
        Returns:
            cfl_loc: dict
                containing coarse flare location as well as ephemeris and chisquare map

        &#34;&#34;&#34;
        pass

    def correct_live_time(self, clone=False):
        &#34;&#34;&#34; Live time correction
        Returns:
          scienceL1 object
        &#34;&#34;&#34;

        trig_tau = FPGA_TAU+ASIC_TAU
        time_bins = self.time_bins[:, None]
        photons_in = self.triggers/(time_bins-trig_tau*self.triggers)
        #photon rate calculated using triggers 
        cm= np.zeros((time_bins.size, 32))
        time_bins = time_bins[:, :, None, None]
        count_rates = self.pixel_counts/time_bins
        for det in range(32):
            trig_idx=inst.detector_id_to_trigger_index(det)

            cm[:,det]= 1 + self.trigger_rates[:,trig_idx]*FPGA_TAU #live time per second 
        self.correct_pixel_count_rates=count_rates*cm[:, :, None, None]/np.exp(-count_rates*ASIC_TAU)
        return self

    def peek(self,
             plots=[&#39;spg&#39;, &#39;lc&#39;, &#39;spec&#39;, &#39;tbin&#39;, &#39;qllc&#39;],
             ax0=None,
             ax1=None,
             ax2=None,
             ax3=None):
        &#34;&#34;&#34;
            Create quick-look plots for the loaded science data
        &#34;&#34;&#34;
        if not self.hdul:
            logger.logger(f&#39;Data not loaded. &#39;)
            return None
        if isinstance(plots, str) and plots:
            plots = plots.split(&#39;,&#39;)
        if not self.data_loaded:
            self.read_fits()
            self.data_loaded = True

        if &#39;spg&#39; in plots:
            if not ax0:
                _, ax0 = plt.subplots()
            X, Y = np.meshgrid(self.time,
                               np.arange(self.min_ebin, self.max_ebin))
            im = ax0.pcolormesh(
                X, Y,
                np.transpose(
                    self.count_rate_spectrogram[:, self.min_ebin:self.max_ebin]
                ))  #pixel summed energy spectrum
            ax0.set_yticks(
                self.energies[&#39;channel&#39;][self.min_ebin:self.max_ebin:2])
            ax0.set_yticklabels(
                self.energy_bin_names[self.min_ebin:self.max_ebin:2])
            fig = plt.gcf()
            cbar = fig.colorbar(im, ax=ax0)
            cbar.set_label(&#39;Counts&#39;)
            ax0.set_title(&#39;Count rate spectrogram&#39;)
            ax0.set_ylabel(&#39;Energy range(keV&#39;)
            ax0.set_xlabel(f&#34;T0 at {self.T0_utc} &#34;)
        if &#39;lc&#39; in plots or &#39;qllc&#39; in plots:
            if not ax1:
                _, ax1 = plt.subplots()
            self.count_rate_spectrogram = self.spectrogram / self.timedel[:,
                                                                          None]
            if &#39;qllc&#39; in plots:
               ql_ebins=[(4, 10),(10 ,15 ),(15 ,25 ),(25 ,50), (50 ,84)]
               labels=(&#39;4 - 10 keV&#39;,&#39;10 - 15 keV&#39;,&#39;15 - 25 keV&#39;,&#39;25 - 50 keV&#39;, &#39;50 - 84 keV&#39;)
               ql_sci_ebins=[self.get_energy_range_slicer(s[0],s[1]) for s in ql_ebins]
               for ebin_slicer,label in zip(ql_sci_ebins, labels):
                   ax1.plot(self.time,
                        np.sum(self.count_rate_spectrogram[:, ebin_slicer], axis=1),label=label) 
                   ax1.set_title(f&#39;Detector summed count rates (L1 request #{self.request_id})&#39;)
            else:
                ax1.plot(
                    self.time,
                    self.count_rate_spectrogram[:, self.min_ebin:self.max_ebin])
            #correct
            ax1.set_ylabel(&#39;counts / sec&#39;)
            #plt.legend(self.energy_bin_names, ncol=4)
            ax1.set_yscale(&#39;log&#39;)
            ax1.set_xlabel(f&#34;seconds since {self.T0_utc} &#34;)
            plt.legend()
        if &#39;spec&#39; in plots:
            if not ax2:
                _, ax2 = plt.subplots()
            ax2.plot(self.ebins_low, self.spectrum, drawstyle=&#39;steps-post&#39;)
            #ax.set_xticks(self.data[3].data[&#39;channel&#39;])
            ax2.set_xscale(&#39;log&#39;)
            ax2.set_yscale(&#39;log&#39;)
            ax2.set_xlabel(&#39;Energy (keV)&#39;)
            ax2.set_ylabel(&#39;Counts&#39;)
        if &#39;tbin&#39; in plots:
            if not ax3:
                _, ax3 = plt.subplots()
            ax3.plot(self.time, self.timedel)
            ax3.set_xlabel(f&#34;T0 at {self.T0_utc} &#34;)
            ax3.set_ylabel(&#39;Integration time (sec)&#39;)
            plt.suptitle(f&#39;L1 request #{self.request_id}&#39;)

        #plt.tight_layout()
        return ax0, ax1, ax2, ax3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stixdcpy.science.ScienceData" href="#stixdcpy.science.ScienceData">ScienceData</a></li>
<li><a title="stixdcpy.io.IO" href="io.html#stixdcpy.io.IO">IO</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stixdcpy.science.ScienceL1.correct_live_time"><code class="name flex">
<span>def <span class="ident">correct_live_time</span></span>(<span>self, clone=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Live time correction</p>
<h2 id="returns">Returns</h2>
<p>scienceL1 object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_live_time(self, clone=False):
    &#34;&#34;&#34; Live time correction
    Returns:
      scienceL1 object
    &#34;&#34;&#34;

    trig_tau = FPGA_TAU+ASIC_TAU
    time_bins = self.time_bins[:, None]
    photons_in = self.triggers/(time_bins-trig_tau*self.triggers)
    #photon rate calculated using triggers 
    cm= np.zeros((time_bins.size, 32))
    time_bins = time_bins[:, :, None, None]
    count_rates = self.pixel_counts/time_bins
    for det in range(32):
        trig_idx=inst.detector_id_to_trigger_index(det)

        cm[:,det]= 1 + self.trigger_rates[:,trig_idx]*FPGA_TAU #live time per second 
    self.correct_pixel_count_rates=count_rates*cm[:, :, None, None]/np.exp(-count_rates*ASIC_TAU)
    return self</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceL1.make_spectra"><code class="name flex">
<span>def <span class="ident">make_spectra</span></span>(<span>self, pixel_counts=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_spectra(self, pixel_counts=None):
    if pixel_counts is None:
        pixel_counts=self.pixel_counts
    self.spectrogram = np.sum(pixel_counts, axis=(1, 2))
    self.count_rate_spectrogram = self.spectrogram / self.timedel[:, np.
                                                                  newaxis]
    self.spectrum = np.sum(pixel_counts, axis=(0, 1, 2))
    self.mean_pixel_rate_spectra = np.sum(self.pixel_counts,
                                          axis=0) / self.duration
    self.mean_pixel_rate_spectra_err = np.sqrt(
        self.mean_pixel_rate_spectra) / np.sqrt(self.duration)
    #sum over all time bins and then divide them by the duration, counts per second</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceL1.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, plots=['spg', 'lc', 'spec', 'tbin', 'qllc'], ax0=None, ax1=None, ax2=None, ax3=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create quick-look plots for the loaded science data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self,
         plots=[&#39;spg&#39;, &#39;lc&#39;, &#39;spec&#39;, &#39;tbin&#39;, &#39;qllc&#39;],
         ax0=None,
         ax1=None,
         ax2=None,
         ax3=None):
    &#34;&#34;&#34;
        Create quick-look plots for the loaded science data
    &#34;&#34;&#34;
    if not self.hdul:
        logger.logger(f&#39;Data not loaded. &#39;)
        return None
    if isinstance(plots, str) and plots:
        plots = plots.split(&#39;,&#39;)
    if not self.data_loaded:
        self.read_fits()
        self.data_loaded = True

    if &#39;spg&#39; in plots:
        if not ax0:
            _, ax0 = plt.subplots()
        X, Y = np.meshgrid(self.time,
                           np.arange(self.min_ebin, self.max_ebin))
        im = ax0.pcolormesh(
            X, Y,
            np.transpose(
                self.count_rate_spectrogram[:, self.min_ebin:self.max_ebin]
            ))  #pixel summed energy spectrum
        ax0.set_yticks(
            self.energies[&#39;channel&#39;][self.min_ebin:self.max_ebin:2])
        ax0.set_yticklabels(
            self.energy_bin_names[self.min_ebin:self.max_ebin:2])
        fig = plt.gcf()
        cbar = fig.colorbar(im, ax=ax0)
        cbar.set_label(&#39;Counts&#39;)
        ax0.set_title(&#39;Count rate spectrogram&#39;)
        ax0.set_ylabel(&#39;Energy range(keV&#39;)
        ax0.set_xlabel(f&#34;T0 at {self.T0_utc} &#34;)
    if &#39;lc&#39; in plots or &#39;qllc&#39; in plots:
        if not ax1:
            _, ax1 = plt.subplots()
        self.count_rate_spectrogram = self.spectrogram / self.timedel[:,
                                                                      None]
        if &#39;qllc&#39; in plots:
           ql_ebins=[(4, 10),(10 ,15 ),(15 ,25 ),(25 ,50), (50 ,84)]
           labels=(&#39;4 - 10 keV&#39;,&#39;10 - 15 keV&#39;,&#39;15 - 25 keV&#39;,&#39;25 - 50 keV&#39;, &#39;50 - 84 keV&#39;)
           ql_sci_ebins=[self.get_energy_range_slicer(s[0],s[1]) for s in ql_ebins]
           for ebin_slicer,label in zip(ql_sci_ebins, labels):
               ax1.plot(self.time,
                    np.sum(self.count_rate_spectrogram[:, ebin_slicer], axis=1),label=label) 
               ax1.set_title(f&#39;Detector summed count rates (L1 request #{self.request_id})&#39;)
        else:
            ax1.plot(
                self.time,
                self.count_rate_spectrogram[:, self.min_ebin:self.max_ebin])
        #correct
        ax1.set_ylabel(&#39;counts / sec&#39;)
        #plt.legend(self.energy_bin_names, ncol=4)
        ax1.set_yscale(&#39;log&#39;)
        ax1.set_xlabel(f&#34;seconds since {self.T0_utc} &#34;)
        plt.legend()
    if &#39;spec&#39; in plots:
        if not ax2:
            _, ax2 = plt.subplots()
        ax2.plot(self.ebins_low, self.spectrum, drawstyle=&#39;steps-post&#39;)
        #ax.set_xticks(self.data[3].data[&#39;channel&#39;])
        ax2.set_xscale(&#39;log&#39;)
        ax2.set_yscale(&#39;log&#39;)
        ax2.set_xlabel(&#39;Energy (keV)&#39;)
        ax2.set_ylabel(&#39;Counts&#39;)
    if &#39;tbin&#39; in plots:
        if not ax3:
            _, ax3 = plt.subplots()
        ax3.plot(self.time, self.timedel)
        ax3.set_xlabel(f&#34;T0 at {self.T0_utc} &#34;)
        ax3.set_ylabel(&#39;Integration time (sec)&#39;)
        plt.suptitle(f&#39;L1 request #{self.request_id}&#39;)

    #plt.tight_layout()
    return ax0, ax1, ax2, ax3</code></pre>
</details>
</dd>
<dt id="stixdcpy.science.ScienceL1.solve_cfl"><code class="name flex">
<span>def <span class="ident">solve_cfl</span></span>(<span>self, start_utc, end_utc, elow=0, eup=31, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate flare location using the online flare location solver.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_utc</code></strong></dt>
<dd>str
ROI start time</dd>
<dt><strong><code>end_utc</code></strong></dt>
<dd>str
ROI end time</dd>
<dt><strong><code>elow</code></strong></dt>
<dd>int
ROI lower energy limit (science channel). </dd>
<dt><strong><code>eup</code></strong></dt>
<dd>int
ROI upper energy limit (science channel). </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cfl_loc</code></dt>
<dd>dict
containing coarse flare location as well as ephemeris and chisquare map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_cfl(self, start_utc, end_utc, elow=0, eup=31, ax=None):
    &#34;&#34;&#34;calculate flare location using the online flare location solver.
      
    Args:
        start_utc: str
            ROI start time
        end_utc: str
            ROI end time
        elow: int
            ROI lower energy limit (science channel). 
        eup: int
            ROI upper energy limit (science channel). 
    Returns:
        cfl_loc: dict
            containing coarse flare location as well as ephemeris and chisquare map

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="stixdcpy.science.ScienceData" href="#stixdcpy.science.ScienceData">ScienceData</a></b></code>:
<ul class="hlist">
<li><code><a title="stixdcpy.science.ScienceData.dump" href="io.html#stixdcpy.io.IO.dump">dump</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.from_fits" href="#stixdcpy.science.ScienceData.from_fits">from_fits</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.from_sdc" href="#stixdcpy.science.ScienceData.from_sdc">from_sdc</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.is_time_bin_shifted" href="#stixdcpy.science.ScienceData.is_time_bin_shifted">is_time_bin_shifted</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.load" href="io.html#stixdcpy.io.IO.load">load</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.read_fits" href="#stixdcpy.science.ScienceData.read_fits">read_fits</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.rebin" href="#stixdcpy.science.ScienceData.rebin">rebin</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.save" href="#stixdcpy.science.ScienceData.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="stixdcpy.science.Spectrogram"><code class="flex name class">
<span>class <span class="ident">Spectrogram</span></span>
<span>(</span><span>reqeust_id, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve science data from stix data center or load fits file from local storage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spectrogram(ScienceData):


    def __init__(self, reqeust_id,fname):
        super().__init__(reqeust_id, fname)
        self.data_type=&#39;Spectrogram&#39;

        self.read_fits()

        self.spectrum = np.sum(self.counts, axis=0)

    def peek(self, ax0=None, ax1=None, ax2=None, ax3=None):
        &#34;&#34;&#34;
            preivew Science data
        Arguments:
        ax0: matplotlib axe 
        ax0: matplotlib axe 
        &#34;&#34;&#34;
        if not self.hdul:
            print(f&#39;Data not loaded. &#39;)
            return None

        #((ax0, ax1), (ax2, ax3))=axs
        if not any([ax0, ax1, ax2, ax3]):
            _, ((ax0, ax1), (ax2, ax3)) = plt.subplots(2, 2, figsize=(8, 6))

        if ax0:
            X, Y = np.meshgrid(self.time,
                               self.hdul[&#39;ENERGIES&#39;].data[&#39;channel&#39;])
            im = ax0.pcolormesh(X, Y, np.transpose(
                self.counts))  #pixel summed energy spectrum
            ax0.set_yticks(self.hdul[&#39;ENERGIES&#39;].data[&#39;channel&#39;][::2])
            ax0.set_yticklabels(self.energy_bin_names[::2])
            fig = plt.gcf()
            cbar = fig.colorbar(im, ax=ax0)
            cbar.set_label(&#39;Counts&#39;)
            ax0.set_title(&#39;Spectrogram&#39;)
            ax0.set_ylabel(&#39;Energy range(keV&#39;)
            ax0.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
        if ax1:
            #convert to 2d
            ax1.plot(self.time, self.count_rates)
            ax1.set_yscale(&#39;log&#39;)
            ax1.set_ylabel(&#39;Counts / sec&#39;)
            ax1.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
        if ax2:
            ax2.plot(self.ebins_low, self.spectrum, drawstyle=&#39;steps-post&#39;)
            ax2.set_xscale(&#39;log&#39;)
            ax2.set_yscale(&#39;log&#39;)
            ax2.set_xlabel(&#39;Energy (keV)&#39;)
            ax2.set_ylabel(&#39;Counts&#39;)
        if ax3:
            ax3.plot(self.time, self.timedel)
            ax3.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
            ax3.set_ylabel(&#39;Integration time (sec)&#39;)
        plt.suptitle(f&#39;L4 request #{self.request_id}&#39;)
        plt.tight_layout()
        return fig, ((ax0, ax1), (ax2, ax3))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stixdcpy.science.ScienceData" href="#stixdcpy.science.ScienceData">ScienceData</a></li>
<li><a title="stixdcpy.io.IO" href="io.html#stixdcpy.io.IO">IO</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stixdcpy.science.Spectrogram.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, ax0=None, ax1=None, ax2=None, ax3=None)</span>
</code></dt>
<dd>
<div class="desc"><p>preivew Science data
Arguments:
ax0: matplotlib axe
ax0: matplotlib axe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self, ax0=None, ax1=None, ax2=None, ax3=None):
    &#34;&#34;&#34;
        preivew Science data
    Arguments:
    ax0: matplotlib axe 
    ax0: matplotlib axe 
    &#34;&#34;&#34;
    if not self.hdul:
        print(f&#39;Data not loaded. &#39;)
        return None

    #((ax0, ax1), (ax2, ax3))=axs
    if not any([ax0, ax1, ax2, ax3]):
        _, ((ax0, ax1), (ax2, ax3)) = plt.subplots(2, 2, figsize=(8, 6))

    if ax0:
        X, Y = np.meshgrid(self.time,
                           self.hdul[&#39;ENERGIES&#39;].data[&#39;channel&#39;])
        im = ax0.pcolormesh(X, Y, np.transpose(
            self.counts))  #pixel summed energy spectrum
        ax0.set_yticks(self.hdul[&#39;ENERGIES&#39;].data[&#39;channel&#39;][::2])
        ax0.set_yticklabels(self.energy_bin_names[::2])
        fig = plt.gcf()
        cbar = fig.colorbar(im, ax=ax0)
        cbar.set_label(&#39;Counts&#39;)
        ax0.set_title(&#39;Spectrogram&#39;)
        ax0.set_ylabel(&#39;Energy range(keV&#39;)
        ax0.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
    if ax1:
        #convert to 2d
        ax1.plot(self.time, self.count_rates)
        ax1.set_yscale(&#39;log&#39;)
        ax1.set_ylabel(&#39;Counts / sec&#39;)
        ax1.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
    if ax2:
        ax2.plot(self.ebins_low, self.spectrum, drawstyle=&#39;steps-post&#39;)
        ax2.set_xscale(&#39;log&#39;)
        ax2.set_yscale(&#39;log&#39;)
        ax2.set_xlabel(&#39;Energy (keV)&#39;)
        ax2.set_ylabel(&#39;Counts&#39;)
    if ax3:
        ax3.plot(self.time, self.timedel)
        ax3.set_xlabel(f&#34;Seconds since {self.T0}s &#34;)
        ax3.set_ylabel(&#39;Integration time (sec)&#39;)
    plt.suptitle(f&#39;L4 request #{self.request_id}&#39;)
    plt.tight_layout()
    return fig, ((ax0, ax1), (ax2, ax3))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="stixdcpy.science.ScienceData" href="#stixdcpy.science.ScienceData">ScienceData</a></b></code>:
<ul class="hlist">
<li><code><a title="stixdcpy.science.ScienceData.dump" href="io.html#stixdcpy.io.IO.dump">dump</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.from_fits" href="#stixdcpy.science.ScienceData.from_fits">from_fits</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.from_sdc" href="#stixdcpy.science.ScienceData.from_sdc">from_sdc</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.is_time_bin_shifted" href="#stixdcpy.science.ScienceData.is_time_bin_shifted">is_time_bin_shifted</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.load" href="io.html#stixdcpy.io.IO.load">load</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.read_fits" href="#stixdcpy.science.ScienceData.read_fits">read_fits</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.rebin" href="#stixdcpy.science.ScienceData.rebin">rebin</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.save" href="#stixdcpy.science.ScienceData.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stixdcpy" href="index.html">stixdcpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stixdcpy.science.ScienceData" href="#stixdcpy.science.ScienceData">ScienceData</a></code></h4>
<ul class="">
<li><code><a title="stixdcpy.science.ScienceData.from_fits" href="#stixdcpy.science.ScienceData.from_fits">from_fits</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.from_sdc" href="#stixdcpy.science.ScienceData.from_sdc">from_sdc</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.get_data" href="#stixdcpy.science.ScienceData.get_data">get_data</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.get_energy_range_slicer" href="#stixdcpy.science.ScienceData.get_energy_range_slicer">get_energy_range_slicer</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.is_time_bin_shifted" href="#stixdcpy.science.ScienceData.is_time_bin_shifted">is_time_bin_shifted</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.read_fits" href="#stixdcpy.science.ScienceData.read_fits">read_fits</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.rebin" href="#stixdcpy.science.ScienceData.rebin">rebin</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.save" href="#stixdcpy.science.ScienceData.save">save</a></code></li>
<li><code><a title="stixdcpy.science.ScienceData.url" href="#stixdcpy.science.ScienceData.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stixdcpy.science.ScienceL1" href="#stixdcpy.science.ScienceL1">ScienceL1</a></code></h4>
<ul class="">
<li><code><a title="stixdcpy.science.ScienceL1.correct_live_time" href="#stixdcpy.science.ScienceL1.correct_live_time">correct_live_time</a></code></li>
<li><code><a title="stixdcpy.science.ScienceL1.make_spectra" href="#stixdcpy.science.ScienceL1.make_spectra">make_spectra</a></code></li>
<li><code><a title="stixdcpy.science.ScienceL1.peek" href="#stixdcpy.science.ScienceL1.peek">peek</a></code></li>
<li><code><a title="stixdcpy.science.ScienceL1.solve_cfl" href="#stixdcpy.science.ScienceL1.solve_cfl">solve_cfl</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stixdcpy.science.Spectrogram" href="#stixdcpy.science.Spectrogram">Spectrogram</a></code></h4>
<ul class="">
<li><code><a title="stixdcpy.science.Spectrogram.peek" href="#stixdcpy.science.Spectrogram.peek">peek</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>