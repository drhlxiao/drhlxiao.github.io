<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stixdcpy.net API documentation</title>
<meta name="description" content="This module provides APIs to retrieve data from STIX data center
Author: Hualin Xiao (hualin.xiao@fhnw.ch)
Date: Sep. 1, 2021" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stixdcpy.net</code></h1>
</header>
<section id="section-intro">
<p>This module provides APIs to retrieve data from STIX data center
Author: Hualin Xiao (hualin.xiao@fhnw.ch)
Date: Sep. 1, 2021</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python
&#34;&#34;&#34;
    This module provides APIs to retrieve data from STIX data center
    Author: Hualin Xiao (hualin.xiao@fhnw.ch)
    Date: Sep. 1, 2021

&#34;&#34;&#34;

import hashlib

import numpy as np
import pandas as pd
import pprint
from pathlib import Path, PurePath
from dateutil import parser as dtparser

import requests
from astropy.io import fits
from tqdm import tqdm

DOWNLOAD_PATH = Path.cwd() / &#39;downloads&#39;
DOWNLOAD_PATH.mkdir(parents=False, exist_ok=True)
HOST = &#39;https://datacenter.stix.i4ds.net&#39;
#HOST=&#39;http://localhost:5000&#39;
URLS_POST = {
    &#39;LC&#39;: f&#39;{HOST}/api/request/ql/lightcurves&#39;,
    &#39;HK&#39;: f&#39;{HOST}/api/request/housekeeping&#39;,
    &#39;HK2&#39;: f&#39;{HOST}/api/request/hk2&#39;,
    &#39;ELUT&#39;: f&#39;{HOST}/api/request/eluts&#39;,
    &#39;EPHEMERIS&#39;: f&#39;{HOST}/api/request/ephemeris&#39;,
    &#39;ATTITUDE&#39;: f&#39;{HOST}/api/request/solo/attitude&#39;,
    &#39;SCIENCE&#39;: f&#39;{HOST}/api/request/science-data/id&#39;,
    &#39;TRANSMISSION&#39;: f&#39;{HOST}/api/request/transmission&#39;,
    &#39;FLARE_LIST&#39;: f&#39;{HOST}/api/request/flare-list&#39;,
    &#39;STIX_POINTING&#39;: f&#39;{HOST}/api/request/stixfov&#39;,
    &#39;CFL_SOLVER&#39;: f&#39;{HOST}/api/request/solve/cfl&#39;
}

FITS_TYPES = {
    &#39;l0&#39;, &#39;l1&#39;, &#39;l2&#39;, &#39;l3&#39;, &#39;spec&#39;, &#39;qlspec&#39;, &#39;asp&#39;, &#39;aspect&#39;, &#39;lc&#39;, &#39;bkg&#39;,
    &#39;var&#39;, &#39;ffl&#39;, &#39;cal&#39;, &#39;hkmin&#39;, &#39;hkmax&#39;
}


class FitsQueryResult(object):
    def __init__(self, resp):
        self.hdu_objects = []
        self.result = resp
        self.downloaded_fits_files = []

    def __repr__(self):
        return str(self.result)

    def __getitem__(self, index):
        return self.result[index]

    def __getattr__(self, name):
        if name in [&#39;num&#39;, &#39;len&#39;]:
            return len(self.result)
        elif name == &#39;hduls&#39;:
            return self.hdu_objects

    def __len__(self):
        return len(self.result)

    def pprint(self):
        pprint.pprint(self.result)

    def to_pandas(self):
        return pd.DataFrame(self.result)

    def open_fits(self):
        self.hdu_objects = []
        for filename in self.downloaded_fits_files:
            self.hdu_objects.append(fits.open(filename))
        return self.hdu_objects

    def fits_info(self):
        for hdu in self.hdu_objects:
            print(hdu.info())

    def get_fits_ids(self):
        return [row[&#39;fits_id&#39;] for row in self.result]

    def fetch(self):
        if self.result:
            self.downloaded_fits_files = FitsQuery.fetch(self.result)
            return self.downloaded_fits_files
        else:
            print(&#39;WARNING: Nothing to be downloaded from stix data center!&#39;)


class FitsQuery(object):
    &#34;&#34;&#34;
    Request FITS format data from STIX data center
    &#34;&#34;&#34;
    def __init__(self):
        self.fits_file_list = []

    @staticmethod
    def wget(url: str, desc: str, progress_bar=True):
        &#34;&#34;&#34;Download a file from the link and save the file to a temporary file.
           Downloading progress will be shown in a progress bar

        Args:
            url (str): URL
            desc (str): description to be shown on the progress bar

        Returns:
            temporary filename 
        &#34;&#34;&#34;
        stream = progress_bar
        resp = requests.get(url, stream=stream)
        content_type = resp.headers.get(&#39;content-type&#39;)
        if content_type != &#39;binary/x-fits&#39;:
            print(&#39;ERROR:&#39;, resp.content)
            return None

        folder = DOWNLOAD_PATH
        try:
            fname = resp.headers.get(&#34;Content-Disposition&#34;).split(
                &#34;filename=&#34;)[1]
        except AttributeError:
            md5hex = hashlib.md5(url.encode(&#39;utf-8&#39;)).hexdigest()
            fname = f&#39;{md5hex}.fits&#39;
        filename = PurePath(folder, fname)
        file_path = Path(filename)
        if file_path.is_file():
            print(f&#39;Found the data in local storage. Filename: {filename} ...&#39;)
            return str(file_path)
        f = open(filename, &#39;wb&#39;)
        chunk_size = 1024
        total = int(resp.headers.get(&#39;content-length&#39;, 0))
        with tqdm(
                desc=desc,
                total=total,
                unit=&#39;iB&#39;,
                unit_scale=True,
                unit_divisor=chunk_size,
        ) as bar:
            for data in resp.iter_content(chunk_size=chunk_size):
                size = f.write(data)
                bar.update(size)
        name = f.name
        f.close()
        return name

    @staticmethod
    def query(start_utc, stop_utc, product_type=&#39;lc&#39;):
        if product_type not in FITS_TYPES:
            raise TypeError(
                f&#39;Invalid product type! product_type can be one of {str(FITS_TYPES)}&#39;
            )
        url = f&#39;{HOST}/query/fits/{start_utc}/{stop_utc}/{product_type}&#39;
        r = requests.get(url).json()
        res = []
        if isinstance(r, list):
            res = r
        elif &#39;error&#39; in r:
            print(r[&#39;error&#39;])
        return FitsQueryResult(res)

    @staticmethod
    def fetch_bulk_science_by_request_id(request_id):
        url = f&#39;{HOST}/download/fits/bsd/{request_id}&#39;
        fname = FitsQuery.wget(url, f&#39;Downloading STIX Science data #{request_id}&#39;)
        return fname

    @staticmethod
    def fetch(query_results):
        fits_ids = []
        if isinstance(query_results, FitsQueryResult):
            fits_ids = query_results.get_fits_ids()
        elif isinstance(query_results, int):
            fits_ids = [query_results]
        elif isinstance(query_results, list):
            try:
                fits_ids = [row[&#39;fits_id&#39;] for row in query_results]
            except Exception as e:
                pass
            if not fits_ids:
                try:
                    fits_ids = [
                        row for row in query_results if isinstance(row, int)
                    ]
                except:
                    pass
        if not fits_ids:
            raise TypeError(&#39;Invalid argument type&#39;)

        fits_filenames = []
        try:
            for file_id in fits_ids:
                fname = FitsQuery.get_fits(file_id)
                fits_filenames.append(fname)
        except Exception as e:
            raise e
        # self.fits_file_list=fits_filenames
        return fits_filenames

    @staticmethod
    def get_fits(fits_id, progress_bar=True):
        &#34;&#34;&#34;Download FITS data products from STIX data center.
        Args:
            fits_id: FITS file ID
            progress_bar: show the progress bar if it is true


        Returns:
            A FITS hdulist object if success;  None if failed
        &#34;&#34;&#34;
        url = f&#39;{HOST}/download/fits/{fits_id}&#39;
        fname = FitsQuery.wget(url, &#39;Downloading data&#39;, progress_bar)
        return fname

    @staticmethod
    def fetch_continuous_data(start_utc, end_utc, data_type):
        if data_type not in [&#39;hkmax&#39;, &#39;lc&#39;, &#39;var&#39;, &#39;qlspec&#39;, &#39;bkg&#39;]:
            raise TypeError(f&#39;Data type {data_type} not supported!&#39;)
        url = f&#39;{HOST}/create/fits/{start_utc}/{end_utc}/{data_type}&#39;
        fname = FitsQuery.wget(url, &#39;Downloading data&#39;, True)
        return fname


class JSONRequest(object):
    &#34;&#34;&#34;Request json format data from STIX data center &#34;&#34;&#34;
    @staticmethod
    def post(url, form):
        response = requests.post(url, data=form)
        data = response.json()

        if &#39;error&#39; in data:
            if data[&#39;error&#39;]:
                return None
        return data

    @staticmethod
    def fetch_light_curves(begin_utc: str, end_utc: str, ltc: bool):
        &#34;&#34;&#34; Request light curve from STIX data center

        Args:
            begin_utc:  str
                Observation start time
            end_utc: str
                Observation end time
            ltc: bool, optional
                Light time correction enabling flag.   Do light time correction if True
        Returns:
            lightcurve: dict
                A python dictionary containing light curve data

        &#34;&#34;&#34;
        form = {&#39;begin&#39;: begin_utc, &#39;ltc&#39;: ltc, &#39;end&#39;: end_utc}
        url = URLS_POST[&#39;LC&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def fetch_housekeeping(begin_utc: str, end_utc: str):
        &#34;&#34;&#34;Fetch housekeeping data from STIX data center

        Args:
            begin_utc: Data start time
            end_utc: data end time

        Returns:
            result:  dict
            housekeeping data

        &#34;&#34;&#34;
        if not begin_utc.endswith(&#39;Z&#39;):
            begin_utc += &#39;Z&#39;
        if not end_utc.endswith(&#39;Z&#39;):
            end_utc += &#39;Z&#39;
        start_unix = dtparser.parse(begin_utc).timestamp()
        end_unix = dtparser.parse(end_utc).timestamp()
        duration = int(end_unix) - int(start_unix)
        form = {
            &#39;start_unix&#39;: start_unix,
            &#39;duration&#39;: duration,
        }
        url = URLS_POST[&#39;HK&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def solve_cfl(cfl_counts, cfl_counts_err, fluence, fluence_err):
        &#34;&#34;&#34;compute flare location using the online flare location solver

        Args:
            cfl_counts: numpy array or list
                counts recorded by the 12 CFL pixels
            cfl_counts_err:  numpy array or list
                standard deviations of  the counts recorded by the 12 CFL pixels
            fluence: float
                X-ray fluence in units of  counts/mm2,  calculated using counts recorded by other detectors
            fluence_err: float
                Errors in fluence in counts/mm2 units
        Returns:
            location: dict
                CFL location, ephemeris and the chisquare map

        &#34;&#34;&#34;
        form = {&#39;counts&#39;: cfl_counts, &#39;counts_err&#39;:cfl_counts_err,
                &#39;fluence&#39;:fluence,&#39;fluence_err&#39;:fluence_err}
        url = URLS_POST[&#39;CFL_SOLVER&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def fetch_elut(utc):
        &#34;&#34;&#34;Download ELUT from STIX data center
        Args:
            utc: Time
        Returns: dict
            object: a diction string containing elut information
        &#34;&#34;&#34;
        form = {&#39;utc&#39;: utc}
        url = URLS_POST[&#39;ELUT&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def request_ephemeris(start_utc: str, end_utc: str, steps=1):
        return JSONRequest.post(URLS_POST[&#39;EPHEMERIS&#39;], {
            &#39;start_utc&#39;: start_utc,
            &#39;end_utc&#39;: end_utc,
            &#39;steps&#39;: steps
        })
    @staticmethod
    def request_pointing(utc: str):
        return JSONRequest.post(URLS_POST[&#39;STIX_POINTING&#39;], {
            &#39;utc&#39;: utc,
        })
    @staticmethod
    def request_attitude(start_utc: str, end_utc: str,  steps=1, instrument_frame=&#39;SOLO_SRF&#39;, ref_frame=&#39;SOLO_SUN_RTN&#39;):
        form={
            &#39;start_utc&#39;: start_utc,
            &#39;end_utc&#39;: end_utc,
            &#39;steps&#39;: steps,
            &#39;frame1&#39;:instrument_frame,
            &#39;frame2&#39;:ref_frame
        }
        ret=JSONRequest.post(URLS_POST[&#39;ATTITUDE&#39;], form)
        return ret
    @staticmethod
    def fetch_science_data(_id: int):
        &#34;&#34;&#34;fetch science data from stix data center

        Args:
            _id: int
                science data unique ID, which can be found on STIX data center bulk science data web page


        Returns:
            science_data: dict
                science data received from data center if success or None if failed

        &#34;&#34;&#34;
        return JSONRequest.post(URLS_POST[&#39;SCIENCE&#39;], {
            &#39;id&#39;: _id,
        })

    @staticmethod
    def fetch_flare_list(start_utc: str, end_utc: str, sort: str = &#39;time&#39;):
        &#34;&#34;&#34; query and download flare list from stix data center

        Args:
            start_utc: str
                flare start UTC
            end_utc: str
                flare end UTC
            sort: str
                key to sort flares. It can be one of [&#39;goes&#39;,&#39;time&#39;, &#39;LC0&#39;,&#39;LC1&#39;,&#39;LC2&#39;,&#39;LC3&#39;,&#39;LC4], LCi here means the i-th QL light curve


        Returns:
            flare_list: dict or None
                flare list if success or None if failed.

        &#34;&#34;&#34;
        return JSONRequest.post(URLS_POST[&#39;FLARE_LIST&#39;], {
            &#39;start_utc&#39;: start_utc,
            &#39;end_utc&#39;: end_utc,
            &#39;sort&#39;: sort
        })</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stixdcpy.net.FitsQuery"><code class="flex name class">
<span>class <span class="ident">FitsQuery</span></span>
</code></dt>
<dd>
<div class="desc"><p>Request FITS format data from STIX data center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FitsQuery(object):
    &#34;&#34;&#34;
    Request FITS format data from STIX data center
    &#34;&#34;&#34;
    def __init__(self):
        self.fits_file_list = []

    @staticmethod
    def wget(url: str, desc: str, progress_bar=True):
        &#34;&#34;&#34;Download a file from the link and save the file to a temporary file.
           Downloading progress will be shown in a progress bar

        Args:
            url (str): URL
            desc (str): description to be shown on the progress bar

        Returns:
            temporary filename 
        &#34;&#34;&#34;
        stream = progress_bar
        resp = requests.get(url, stream=stream)
        content_type = resp.headers.get(&#39;content-type&#39;)
        if content_type != &#39;binary/x-fits&#39;:
            print(&#39;ERROR:&#39;, resp.content)
            return None

        folder = DOWNLOAD_PATH
        try:
            fname = resp.headers.get(&#34;Content-Disposition&#34;).split(
                &#34;filename=&#34;)[1]
        except AttributeError:
            md5hex = hashlib.md5(url.encode(&#39;utf-8&#39;)).hexdigest()
            fname = f&#39;{md5hex}.fits&#39;
        filename = PurePath(folder, fname)
        file_path = Path(filename)
        if file_path.is_file():
            print(f&#39;Found the data in local storage. Filename: {filename} ...&#39;)
            return str(file_path)
        f = open(filename, &#39;wb&#39;)
        chunk_size = 1024
        total = int(resp.headers.get(&#39;content-length&#39;, 0))
        with tqdm(
                desc=desc,
                total=total,
                unit=&#39;iB&#39;,
                unit_scale=True,
                unit_divisor=chunk_size,
        ) as bar:
            for data in resp.iter_content(chunk_size=chunk_size):
                size = f.write(data)
                bar.update(size)
        name = f.name
        f.close()
        return name

    @staticmethod
    def query(start_utc, stop_utc, product_type=&#39;lc&#39;):
        if product_type not in FITS_TYPES:
            raise TypeError(
                f&#39;Invalid product type! product_type can be one of {str(FITS_TYPES)}&#39;
            )
        url = f&#39;{HOST}/query/fits/{start_utc}/{stop_utc}/{product_type}&#39;
        r = requests.get(url).json()
        res = []
        if isinstance(r, list):
            res = r
        elif &#39;error&#39; in r:
            print(r[&#39;error&#39;])
        return FitsQueryResult(res)

    @staticmethod
    def fetch_bulk_science_by_request_id(request_id):
        url = f&#39;{HOST}/download/fits/bsd/{request_id}&#39;
        fname = FitsQuery.wget(url, f&#39;Downloading STIX Science data #{request_id}&#39;)
        return fname

    @staticmethod
    def fetch(query_results):
        fits_ids = []
        if isinstance(query_results, FitsQueryResult):
            fits_ids = query_results.get_fits_ids()
        elif isinstance(query_results, int):
            fits_ids = [query_results]
        elif isinstance(query_results, list):
            try:
                fits_ids = [row[&#39;fits_id&#39;] for row in query_results]
            except Exception as e:
                pass
            if not fits_ids:
                try:
                    fits_ids = [
                        row for row in query_results if isinstance(row, int)
                    ]
                except:
                    pass
        if not fits_ids:
            raise TypeError(&#39;Invalid argument type&#39;)

        fits_filenames = []
        try:
            for file_id in fits_ids:
                fname = FitsQuery.get_fits(file_id)
                fits_filenames.append(fname)
        except Exception as e:
            raise e
        # self.fits_file_list=fits_filenames
        return fits_filenames

    @staticmethod
    def get_fits(fits_id, progress_bar=True):
        &#34;&#34;&#34;Download FITS data products from STIX data center.
        Args:
            fits_id: FITS file ID
            progress_bar: show the progress bar if it is true


        Returns:
            A FITS hdulist object if success;  None if failed
        &#34;&#34;&#34;
        url = f&#39;{HOST}/download/fits/{fits_id}&#39;
        fname = FitsQuery.wget(url, &#39;Downloading data&#39;, progress_bar)
        return fname

    @staticmethod
    def fetch_continuous_data(start_utc, end_utc, data_type):
        if data_type not in [&#39;hkmax&#39;, &#39;lc&#39;, &#39;var&#39;, &#39;qlspec&#39;, &#39;bkg&#39;]:
            raise TypeError(f&#39;Data type {data_type} not supported!&#39;)
        url = f&#39;{HOST}/create/fits/{start_utc}/{end_utc}/{data_type}&#39;
        fname = FitsQuery.wget(url, &#39;Downloading data&#39;, True)
        return fname</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="stixdcpy.net.FitsQuery.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>query_results)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch(query_results):
    fits_ids = []
    if isinstance(query_results, FitsQueryResult):
        fits_ids = query_results.get_fits_ids()
    elif isinstance(query_results, int):
        fits_ids = [query_results]
    elif isinstance(query_results, list):
        try:
            fits_ids = [row[&#39;fits_id&#39;] for row in query_results]
        except Exception as e:
            pass
        if not fits_ids:
            try:
                fits_ids = [
                    row for row in query_results if isinstance(row, int)
                ]
            except:
                pass
    if not fits_ids:
        raise TypeError(&#39;Invalid argument type&#39;)

    fits_filenames = []
    try:
        for file_id in fits_ids:
            fname = FitsQuery.get_fits(file_id)
            fits_filenames.append(fname)
    except Exception as e:
        raise e
    # self.fits_file_list=fits_filenames
    return fits_filenames</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQuery.fetch_bulk_science_by_request_id"><code class="name flex">
<span>def <span class="ident">fetch_bulk_science_by_request_id</span></span>(<span>request_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_bulk_science_by_request_id(request_id):
    url = f&#39;{HOST}/download/fits/bsd/{request_id}&#39;
    fname = FitsQuery.wget(url, f&#39;Downloading STIX Science data #{request_id}&#39;)
    return fname</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQuery.fetch_continuous_data"><code class="name flex">
<span>def <span class="ident">fetch_continuous_data</span></span>(<span>start_utc, end_utc, data_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_continuous_data(start_utc, end_utc, data_type):
    if data_type not in [&#39;hkmax&#39;, &#39;lc&#39;, &#39;var&#39;, &#39;qlspec&#39;, &#39;bkg&#39;]:
        raise TypeError(f&#39;Data type {data_type} not supported!&#39;)
    url = f&#39;{HOST}/create/fits/{start_utc}/{end_utc}/{data_type}&#39;
    fname = FitsQuery.wget(url, &#39;Downloading data&#39;, True)
    return fname</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQuery.get_fits"><code class="name flex">
<span>def <span class="ident">get_fits</span></span>(<span>fits_id, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Download FITS data products from STIX data center.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fits_id</code></strong></dt>
<dd>FITS file ID</dd>
<dt><strong><code>progress_bar</code></strong></dt>
<dd>show the progress bar if it is true</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A FITS hdulist object if success;
None if failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_fits(fits_id, progress_bar=True):
    &#34;&#34;&#34;Download FITS data products from STIX data center.
    Args:
        fits_id: FITS file ID
        progress_bar: show the progress bar if it is true


    Returns:
        A FITS hdulist object if success;  None if failed
    &#34;&#34;&#34;
    url = f&#39;{HOST}/download/fits/{fits_id}&#39;
    fname = FitsQuery.wget(url, &#39;Downloading data&#39;, progress_bar)
    return fname</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQuery.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>start_utc, stop_utc, product_type='lc')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def query(start_utc, stop_utc, product_type=&#39;lc&#39;):
    if product_type not in FITS_TYPES:
        raise TypeError(
            f&#39;Invalid product type! product_type can be one of {str(FITS_TYPES)}&#39;
        )
    url = f&#39;{HOST}/query/fits/{start_utc}/{stop_utc}/{product_type}&#39;
    r = requests.get(url).json()
    res = []
    if isinstance(r, list):
        res = r
    elif &#39;error&#39; in r:
        print(r[&#39;error&#39;])
    return FitsQueryResult(res)</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQuery.wget"><code class="name flex">
<span>def <span class="ident">wget</span></span>(<span>url: str, desc: str, progress_bar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Download a file from the link and save the file to a temporary file.
Downloading progress will be shown in a progress bar</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code></dt>
<dd>description to be shown on the progress bar</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>temporary filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def wget(url: str, desc: str, progress_bar=True):
    &#34;&#34;&#34;Download a file from the link and save the file to a temporary file.
       Downloading progress will be shown in a progress bar

    Args:
        url (str): URL
        desc (str): description to be shown on the progress bar

    Returns:
        temporary filename 
    &#34;&#34;&#34;
    stream = progress_bar
    resp = requests.get(url, stream=stream)
    content_type = resp.headers.get(&#39;content-type&#39;)
    if content_type != &#39;binary/x-fits&#39;:
        print(&#39;ERROR:&#39;, resp.content)
        return None

    folder = DOWNLOAD_PATH
    try:
        fname = resp.headers.get(&#34;Content-Disposition&#34;).split(
            &#34;filename=&#34;)[1]
    except AttributeError:
        md5hex = hashlib.md5(url.encode(&#39;utf-8&#39;)).hexdigest()
        fname = f&#39;{md5hex}.fits&#39;
    filename = PurePath(folder, fname)
    file_path = Path(filename)
    if file_path.is_file():
        print(f&#39;Found the data in local storage. Filename: {filename} ...&#39;)
        return str(file_path)
    f = open(filename, &#39;wb&#39;)
    chunk_size = 1024
    total = int(resp.headers.get(&#39;content-length&#39;, 0))
    with tqdm(
            desc=desc,
            total=total,
            unit=&#39;iB&#39;,
            unit_scale=True,
            unit_divisor=chunk_size,
    ) as bar:
        for data in resp.iter_content(chunk_size=chunk_size):
            size = f.write(data)
            bar.update(size)
    name = f.name
    f.close()
    return name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stixdcpy.net.FitsQueryResult"><code class="flex name class">
<span>class <span class="ident">FitsQueryResult</span></span>
<span>(</span><span>resp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FitsQueryResult(object):
    def __init__(self, resp):
        self.hdu_objects = []
        self.result = resp
        self.downloaded_fits_files = []

    def __repr__(self):
        return str(self.result)

    def __getitem__(self, index):
        return self.result[index]

    def __getattr__(self, name):
        if name in [&#39;num&#39;, &#39;len&#39;]:
            return len(self.result)
        elif name == &#39;hduls&#39;:
            return self.hdu_objects

    def __len__(self):
        return len(self.result)

    def pprint(self):
        pprint.pprint(self.result)

    def to_pandas(self):
        return pd.DataFrame(self.result)

    def open_fits(self):
        self.hdu_objects = []
        for filename in self.downloaded_fits_files:
            self.hdu_objects.append(fits.open(filename))
        return self.hdu_objects

    def fits_info(self):
        for hdu in self.hdu_objects:
            print(hdu.info())

    def get_fits_ids(self):
        return [row[&#39;fits_id&#39;] for row in self.result]

    def fetch(self):
        if self.result:
            self.downloaded_fits_files = FitsQuery.fetch(self.result)
            return self.downloaded_fits_files
        else:
            print(&#39;WARNING: Nothing to be downloaded from stix data center!&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="stixdcpy.net.FitsQueryResult.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self):
    if self.result:
        self.downloaded_fits_files = FitsQuery.fetch(self.result)
        return self.downloaded_fits_files
    else:
        print(&#39;WARNING: Nothing to be downloaded from stix data center!&#39;)</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQueryResult.fits_info"><code class="name flex">
<span>def <span class="ident">fits_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fits_info(self):
    for hdu in self.hdu_objects:
        print(hdu.info())</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQueryResult.get_fits_ids"><code class="name flex">
<span>def <span class="ident">get_fits_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fits_ids(self):
    return [row[&#39;fits_id&#39;] for row in self.result]</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQueryResult.open_fits"><code class="name flex">
<span>def <span class="ident">open_fits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_fits(self):
    self.hdu_objects = []
    for filename in self.downloaded_fits_files:
        self.hdu_objects.append(fits.open(filename))
    return self.hdu_objects</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQueryResult.pprint"><code class="name flex">
<span>def <span class="ident">pprint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pprint(self):
    pprint.pprint(self.result)</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.FitsQueryResult.to_pandas"><code class="name flex">
<span>def <span class="ident">to_pandas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pandas(self):
    return pd.DataFrame(self.result)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stixdcpy.net.JSONRequest"><code class="flex name class">
<span>class <span class="ident">JSONRequest</span></span>
</code></dt>
<dd>
<div class="desc"><p>Request json format data from STIX data center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONRequest(object):
    &#34;&#34;&#34;Request json format data from STIX data center &#34;&#34;&#34;
    @staticmethod
    def post(url, form):
        response = requests.post(url, data=form)
        data = response.json()

        if &#39;error&#39; in data:
            if data[&#39;error&#39;]:
                return None
        return data

    @staticmethod
    def fetch_light_curves(begin_utc: str, end_utc: str, ltc: bool):
        &#34;&#34;&#34; Request light curve from STIX data center

        Args:
            begin_utc:  str
                Observation start time
            end_utc: str
                Observation end time
            ltc: bool, optional
                Light time correction enabling flag.   Do light time correction if True
        Returns:
            lightcurve: dict
                A python dictionary containing light curve data

        &#34;&#34;&#34;
        form = {&#39;begin&#39;: begin_utc, &#39;ltc&#39;: ltc, &#39;end&#39;: end_utc}
        url = URLS_POST[&#39;LC&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def fetch_housekeeping(begin_utc: str, end_utc: str):
        &#34;&#34;&#34;Fetch housekeeping data from STIX data center

        Args:
            begin_utc: Data start time
            end_utc: data end time

        Returns:
            result:  dict
            housekeeping data

        &#34;&#34;&#34;
        if not begin_utc.endswith(&#39;Z&#39;):
            begin_utc += &#39;Z&#39;
        if not end_utc.endswith(&#39;Z&#39;):
            end_utc += &#39;Z&#39;
        start_unix = dtparser.parse(begin_utc).timestamp()
        end_unix = dtparser.parse(end_utc).timestamp()
        duration = int(end_unix) - int(start_unix)
        form = {
            &#39;start_unix&#39;: start_unix,
            &#39;duration&#39;: duration,
        }
        url = URLS_POST[&#39;HK&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def solve_cfl(cfl_counts, cfl_counts_err, fluence, fluence_err):
        &#34;&#34;&#34;compute flare location using the online flare location solver

        Args:
            cfl_counts: numpy array or list
                counts recorded by the 12 CFL pixels
            cfl_counts_err:  numpy array or list
                standard deviations of  the counts recorded by the 12 CFL pixels
            fluence: float
                X-ray fluence in units of  counts/mm2,  calculated using counts recorded by other detectors
            fluence_err: float
                Errors in fluence in counts/mm2 units
        Returns:
            location: dict
                CFL location, ephemeris and the chisquare map

        &#34;&#34;&#34;
        form = {&#39;counts&#39;: cfl_counts, &#39;counts_err&#39;:cfl_counts_err,
                &#39;fluence&#39;:fluence,&#39;fluence_err&#39;:fluence_err}
        url = URLS_POST[&#39;CFL_SOLVER&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def fetch_elut(utc):
        &#34;&#34;&#34;Download ELUT from STIX data center
        Args:
            utc: Time
        Returns: dict
            object: a diction string containing elut information
        &#34;&#34;&#34;
        form = {&#39;utc&#39;: utc}
        url = URLS_POST[&#39;ELUT&#39;]
        return JSONRequest.post(url, form)

    @staticmethod
    def request_ephemeris(start_utc: str, end_utc: str, steps=1):
        return JSONRequest.post(URLS_POST[&#39;EPHEMERIS&#39;], {
            &#39;start_utc&#39;: start_utc,
            &#39;end_utc&#39;: end_utc,
            &#39;steps&#39;: steps
        })
    @staticmethod
    def request_pointing(utc: str):
        return JSONRequest.post(URLS_POST[&#39;STIX_POINTING&#39;], {
            &#39;utc&#39;: utc,
        })
    @staticmethod
    def request_attitude(start_utc: str, end_utc: str,  steps=1, instrument_frame=&#39;SOLO_SRF&#39;, ref_frame=&#39;SOLO_SUN_RTN&#39;):
        form={
            &#39;start_utc&#39;: start_utc,
            &#39;end_utc&#39;: end_utc,
            &#39;steps&#39;: steps,
            &#39;frame1&#39;:instrument_frame,
            &#39;frame2&#39;:ref_frame
        }
        ret=JSONRequest.post(URLS_POST[&#39;ATTITUDE&#39;], form)
        return ret
    @staticmethod
    def fetch_science_data(_id: int):
        &#34;&#34;&#34;fetch science data from stix data center

        Args:
            _id: int
                science data unique ID, which can be found on STIX data center bulk science data web page


        Returns:
            science_data: dict
                science data received from data center if success or None if failed

        &#34;&#34;&#34;
        return JSONRequest.post(URLS_POST[&#39;SCIENCE&#39;], {
            &#39;id&#39;: _id,
        })

    @staticmethod
    def fetch_flare_list(start_utc: str, end_utc: str, sort: str = &#39;time&#39;):
        &#34;&#34;&#34; query and download flare list from stix data center

        Args:
            start_utc: str
                flare start UTC
            end_utc: str
                flare end UTC
            sort: str
                key to sort flares. It can be one of [&#39;goes&#39;,&#39;time&#39;, &#39;LC0&#39;,&#39;LC1&#39;,&#39;LC2&#39;,&#39;LC3&#39;,&#39;LC4], LCi here means the i-th QL light curve


        Returns:
            flare_list: dict or None
                flare list if success or None if failed.

        &#34;&#34;&#34;
        return JSONRequest.post(URLS_POST[&#39;FLARE_LIST&#39;], {
            &#39;start_utc&#39;: start_utc,
            &#39;end_utc&#39;: end_utc,
            &#39;sort&#39;: sort
        })</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="stixdcpy.net.JSONRequest.fetch_elut"><code class="name flex">
<span>def <span class="ident">fetch_elut</span></span>(<span>utc)</span>
</code></dt>
<dd>
<div class="desc"><p>Download ELUT from STIX data center</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>utc</code></strong></dt>
<dd>Time</dd>
</dl>
<p>Returns: dict
object: a diction string containing elut information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_elut(utc):
    &#34;&#34;&#34;Download ELUT from STIX data center
    Args:
        utc: Time
    Returns: dict
        object: a diction string containing elut information
    &#34;&#34;&#34;
    form = {&#39;utc&#39;: utc}
    url = URLS_POST[&#39;ELUT&#39;]
    return JSONRequest.post(url, form)</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.fetch_flare_list"><code class="name flex">
<span>def <span class="ident">fetch_flare_list</span></span>(<span>start_utc: str, end_utc: str, sort: str = 'time')</span>
</code></dt>
<dd>
<div class="desc"><p>query and download flare list from stix data center</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_utc</code></strong></dt>
<dd>str
flare start UTC</dd>
<dt><strong><code>end_utc</code></strong></dt>
<dd>str
flare end UTC</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>str
key to sort flares. It can be one of ['goes','time', 'LC0','LC1','LC2','LC3','LC4], LCi here means the i-th QL light curve</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>flare_list</code></dt>
<dd>dict or None
flare list if success or None if failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_flare_list(start_utc: str, end_utc: str, sort: str = &#39;time&#39;):
    &#34;&#34;&#34; query and download flare list from stix data center

    Args:
        start_utc: str
            flare start UTC
        end_utc: str
            flare end UTC
        sort: str
            key to sort flares. It can be one of [&#39;goes&#39;,&#39;time&#39;, &#39;LC0&#39;,&#39;LC1&#39;,&#39;LC2&#39;,&#39;LC3&#39;,&#39;LC4], LCi here means the i-th QL light curve


    Returns:
        flare_list: dict or None
            flare list if success or None if failed.

    &#34;&#34;&#34;
    return JSONRequest.post(URLS_POST[&#39;FLARE_LIST&#39;], {
        &#39;start_utc&#39;: start_utc,
        &#39;end_utc&#39;: end_utc,
        &#39;sort&#39;: sort
    })</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.fetch_housekeeping"><code class="name flex">
<span>def <span class="ident">fetch_housekeeping</span></span>(<span>begin_utc: str, end_utc: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch housekeeping data from STIX data center</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>begin_utc</code></strong></dt>
<dd>Data start time</dd>
<dt><strong><code>end_utc</code></strong></dt>
<dd>data end time</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>result</code></dt>
<dd>dict</dd>
</dl>
<p>housekeeping data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_housekeeping(begin_utc: str, end_utc: str):
    &#34;&#34;&#34;Fetch housekeeping data from STIX data center

    Args:
        begin_utc: Data start time
        end_utc: data end time

    Returns:
        result:  dict
        housekeeping data

    &#34;&#34;&#34;
    if not begin_utc.endswith(&#39;Z&#39;):
        begin_utc += &#39;Z&#39;
    if not end_utc.endswith(&#39;Z&#39;):
        end_utc += &#39;Z&#39;
    start_unix = dtparser.parse(begin_utc).timestamp()
    end_unix = dtparser.parse(end_utc).timestamp()
    duration = int(end_unix) - int(start_unix)
    form = {
        &#39;start_unix&#39;: start_unix,
        &#39;duration&#39;: duration,
    }
    url = URLS_POST[&#39;HK&#39;]
    return JSONRequest.post(url, form)</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.fetch_light_curves"><code class="name flex">
<span>def <span class="ident">fetch_light_curves</span></span>(<span>begin_utc: str, end_utc: str, ltc: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Request light curve from STIX data center</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>begin_utc</code></strong></dt>
<dd>str
Observation start time</dd>
<dt><strong><code>end_utc</code></strong></dt>
<dd>str
Observation end time</dd>
<dt><strong><code>ltc</code></strong></dt>
<dd>bool, optional
Light time correction enabling flag.
Do light time correction if True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lightcurve</code></dt>
<dd>dict
A python dictionary containing light curve data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_light_curves(begin_utc: str, end_utc: str, ltc: bool):
    &#34;&#34;&#34; Request light curve from STIX data center

    Args:
        begin_utc:  str
            Observation start time
        end_utc: str
            Observation end time
        ltc: bool, optional
            Light time correction enabling flag.   Do light time correction if True
    Returns:
        lightcurve: dict
            A python dictionary containing light curve data

    &#34;&#34;&#34;
    form = {&#39;begin&#39;: begin_utc, &#39;ltc&#39;: ltc, &#39;end&#39;: end_utc}
    url = URLS_POST[&#39;LC&#39;]
    return JSONRequest.post(url, form)</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.fetch_science_data"><code class="name flex">
<span>def <span class="ident">fetch_science_data</span></span>(<span>_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>fetch science data from stix data center</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_id</code></strong></dt>
<dd>int
science data unique ID, which can be found on STIX data center bulk science data web page</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>science_data</code></dt>
<dd>dict
science data received from data center if success or None if failed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fetch_science_data(_id: int):
    &#34;&#34;&#34;fetch science data from stix data center

    Args:
        _id: int
            science data unique ID, which can be found on STIX data center bulk science data web page


    Returns:
        science_data: dict
            science data received from data center if success or None if failed

    &#34;&#34;&#34;
    return JSONRequest.post(URLS_POST[&#39;SCIENCE&#39;], {
        &#39;id&#39;: _id,
    })</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>url, form)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def post(url, form):
    response = requests.post(url, data=form)
    data = response.json()

    if &#39;error&#39; in data:
        if data[&#39;error&#39;]:
            return None
    return data</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.request_attitude"><code class="name flex">
<span>def <span class="ident">request_attitude</span></span>(<span>start_utc: str, end_utc: str, steps=1, instrument_frame='SOLO_SRF', ref_frame='SOLO_SUN_RTN')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def request_attitude(start_utc: str, end_utc: str,  steps=1, instrument_frame=&#39;SOLO_SRF&#39;, ref_frame=&#39;SOLO_SUN_RTN&#39;):
    form={
        &#39;start_utc&#39;: start_utc,
        &#39;end_utc&#39;: end_utc,
        &#39;steps&#39;: steps,
        &#39;frame1&#39;:instrument_frame,
        &#39;frame2&#39;:ref_frame
    }
    ret=JSONRequest.post(URLS_POST[&#39;ATTITUDE&#39;], form)
    return ret</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.request_ephemeris"><code class="name flex">
<span>def <span class="ident">request_ephemeris</span></span>(<span>start_utc: str, end_utc: str, steps=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def request_ephemeris(start_utc: str, end_utc: str, steps=1):
    return JSONRequest.post(URLS_POST[&#39;EPHEMERIS&#39;], {
        &#39;start_utc&#39;: start_utc,
        &#39;end_utc&#39;: end_utc,
        &#39;steps&#39;: steps
    })</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.request_pointing"><code class="name flex">
<span>def <span class="ident">request_pointing</span></span>(<span>utc: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def request_pointing(utc: str):
    return JSONRequest.post(URLS_POST[&#39;STIX_POINTING&#39;], {
        &#39;utc&#39;: utc,
    })</code></pre>
</details>
</dd>
<dt id="stixdcpy.net.JSONRequest.solve_cfl"><code class="name flex">
<span>def <span class="ident">solve_cfl</span></span>(<span>cfl_counts, cfl_counts_err, fluence, fluence_err)</span>
</code></dt>
<dd>
<div class="desc"><p>compute flare location using the online flare location solver</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cfl_counts</code></strong></dt>
<dd>numpy array or list
counts recorded by the 12 CFL pixels</dd>
<dt><strong><code>cfl_counts_err</code></strong></dt>
<dd>numpy array or list
standard deviations of
the counts recorded by the 12 CFL pixels</dd>
<dt><strong><code>fluence</code></strong></dt>
<dd>float
X-ray fluence in units of
counts/mm2,
calculated using counts recorded by other detectors</dd>
<dt><strong><code>fluence_err</code></strong></dt>
<dd>float
Errors in fluence in counts/mm2 units</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>location</code></dt>
<dd>dict
CFL location, ephemeris and the chisquare map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def solve_cfl(cfl_counts, cfl_counts_err, fluence, fluence_err):
    &#34;&#34;&#34;compute flare location using the online flare location solver

    Args:
        cfl_counts: numpy array or list
            counts recorded by the 12 CFL pixels
        cfl_counts_err:  numpy array or list
            standard deviations of  the counts recorded by the 12 CFL pixels
        fluence: float
            X-ray fluence in units of  counts/mm2,  calculated using counts recorded by other detectors
        fluence_err: float
            Errors in fluence in counts/mm2 units
    Returns:
        location: dict
            CFL location, ephemeris and the chisquare map

    &#34;&#34;&#34;
    form = {&#39;counts&#39;: cfl_counts, &#39;counts_err&#39;:cfl_counts_err,
            &#39;fluence&#39;:fluence,&#39;fluence_err&#39;:fluence_err}
    url = URLS_POST[&#39;CFL_SOLVER&#39;]
    return JSONRequest.post(url, form)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stixdcpy" href="index.html">stixdcpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stixdcpy.net.FitsQuery" href="#stixdcpy.net.FitsQuery">FitsQuery</a></code></h4>
<ul class="">
<li><code><a title="stixdcpy.net.FitsQuery.fetch" href="#stixdcpy.net.FitsQuery.fetch">fetch</a></code></li>
<li><code><a title="stixdcpy.net.FitsQuery.fetch_bulk_science_by_request_id" href="#stixdcpy.net.FitsQuery.fetch_bulk_science_by_request_id">fetch_bulk_science_by_request_id</a></code></li>
<li><code><a title="stixdcpy.net.FitsQuery.fetch_continuous_data" href="#stixdcpy.net.FitsQuery.fetch_continuous_data">fetch_continuous_data</a></code></li>
<li><code><a title="stixdcpy.net.FitsQuery.get_fits" href="#stixdcpy.net.FitsQuery.get_fits">get_fits</a></code></li>
<li><code><a title="stixdcpy.net.FitsQuery.query" href="#stixdcpy.net.FitsQuery.query">query</a></code></li>
<li><code><a title="stixdcpy.net.FitsQuery.wget" href="#stixdcpy.net.FitsQuery.wget">wget</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stixdcpy.net.FitsQueryResult" href="#stixdcpy.net.FitsQueryResult">FitsQueryResult</a></code></h4>
<ul class="two-column">
<li><code><a title="stixdcpy.net.FitsQueryResult.fetch" href="#stixdcpy.net.FitsQueryResult.fetch">fetch</a></code></li>
<li><code><a title="stixdcpy.net.FitsQueryResult.fits_info" href="#stixdcpy.net.FitsQueryResult.fits_info">fits_info</a></code></li>
<li><code><a title="stixdcpy.net.FitsQueryResult.get_fits_ids" href="#stixdcpy.net.FitsQueryResult.get_fits_ids">get_fits_ids</a></code></li>
<li><code><a title="stixdcpy.net.FitsQueryResult.open_fits" href="#stixdcpy.net.FitsQueryResult.open_fits">open_fits</a></code></li>
<li><code><a title="stixdcpy.net.FitsQueryResult.pprint" href="#stixdcpy.net.FitsQueryResult.pprint">pprint</a></code></li>
<li><code><a title="stixdcpy.net.FitsQueryResult.to_pandas" href="#stixdcpy.net.FitsQueryResult.to_pandas">to_pandas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stixdcpy.net.JSONRequest" href="#stixdcpy.net.JSONRequest">JSONRequest</a></code></h4>
<ul class="two-column">
<li><code><a title="stixdcpy.net.JSONRequest.fetch_elut" href="#stixdcpy.net.JSONRequest.fetch_elut">fetch_elut</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.fetch_flare_list" href="#stixdcpy.net.JSONRequest.fetch_flare_list">fetch_flare_list</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.fetch_housekeeping" href="#stixdcpy.net.JSONRequest.fetch_housekeeping">fetch_housekeeping</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.fetch_light_curves" href="#stixdcpy.net.JSONRequest.fetch_light_curves">fetch_light_curves</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.fetch_science_data" href="#stixdcpy.net.JSONRequest.fetch_science_data">fetch_science_data</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.post" href="#stixdcpy.net.JSONRequest.post">post</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.request_attitude" href="#stixdcpy.net.JSONRequest.request_attitude">request_attitude</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.request_ephemeris" href="#stixdcpy.net.JSONRequest.request_ephemeris">request_ephemeris</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.request_pointing" href="#stixdcpy.net.JSONRequest.request_pointing">request_pointing</a></code></li>
<li><code><a title="stixdcpy.net.JSONRequest.solve_cfl" href="#stixdcpy.net.JSONRequest.solve_cfl">solve_cfl</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>